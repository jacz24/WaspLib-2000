(*
# Map
This file is responsible for the TRSMap positioning system.
It was made from scratch by Torwent but heavily inspired in the original
TRSWalker by [slacky](https://slacky.one/) and it's future iterations made by
Olly.
Without them, this wouldn't be possible.

For a online interactive map you can visit
[WaspScripts map](https://map.waspscripts.com/)

For something simpler and much closer to the original
[slacky](https://slacky.one/) walker check out {ref}`Image Map`.
*)

{$DEFINE WL_MAP_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
(*
## TRSPosition
Record holding a player's full position:
- X, Y coordinate
- Z which is the player height on the current heightmap
- Plane which is the player's current plane if several planes are being used.
*)
  TRSPosition = record
    X, Y, Plane: Integer;
    Z: Single;
  end;

function TRSPosition.ToPoint(): TPoint;
begin
  Result := [Self.X, Self.Y];
end;

type
(*
## TRSMap
Record responsible for positioning.
*)
  TRSMap = record
    RegionIndex: Integer;
    Region: TRSMapRegion;

    Walker: TRSWalker;

    Similarity: Single;
    Cache: record
      LocalPosition: TPoint;
      Position: TPoint;
      FullPosition: TRSPosition;
      MatchTemplate: TMatchTemplateCache;
    end;
    Loader: TRSMapLoader;

    Sample: TRSMapSample;

    Filters: TBoxFilterArray;

    IsSetup, DisableHeightmap: Boolean;

    //Dynamic loading
    DynamicLoading: record
      Enabled: Boolean;
      EdgeThreshold: Integer;  //Pixels from edge to trigger loading
      ChunkRadius: Integer;    //Chunks to load around current position
      LastExpansion: TPoint;   //Last chunk we expanded from
      Loading: Boolean;        //Currently loading chunks
      Preloading: Boolean;     //Currently preloading path
      PreviousOnWalkEvent: TRSWalkerEvent;
    end;
  end;

  PRSMap = ^TRSMap;

function TRSMap.Position(): TPoint; forward;

function TRSMap.Height(pt: TPoint = [0,0]; global: Boolean = True): Single; forward;


(*
## Map.InternalSetup
```pascal
procedure TRSMap.InternalSetup();
```
Internal TRSMap setup method.
This is caleld automatically for you and you shouldn't need to call it.
*)
procedure TRSMap.InternalSetup();
var
  img, sample: TImage;
  i: Integer;
  b: TBox;
begin
  if Self.Sample.Amount = 0 then Self.Sample.Amount := 4;
  if Self.Sample.Radius = 0 then Self.Sample.Radius := -1;

  if Minimap.Radius = 0 then
  begin
    WriteLn GetDebugLn('Map', 'Minimap.Radius is 0, did you target the client? Using 65 for now.', ELogLevel.WARN);
    WriteLn GetDebugLn('Map', 'If you are botting focus the client and restart or you will have issues.', ELogLevel.WARN);
    img := new TImage(131,131);
    img.ReplaceColor($0, $FFFFFF);
    sample := Minimap.ScaleMinimap(img, Self.Loader.Downscale, 65);
  end
  else
  begin
    i := Minimap.Radius*2+1;
    img := new TImage(i,i);
    img.ReplaceColor($0, $FFFFFF);
    sample := Minimap.ScaleMinimap(img, Self.Loader.Downscale, Self.Sample.Radius);
  end;

  Self.Cache.MatchTemplate := TMatchTemplateCache.Create(Self.Loader.DownscaledMap, sample, ETMFormula.TM_CCOEFF_NORMED);
  Self.Cache.MatchTemplate.FreeOnTerminate := True;

  Self.Filters := [];
  for i := 0 to High(Self.Loader.Regions) do
  begin
    b := Self.Loader.Regions[i].Region.Expand(-(Self.Loader.Padding));
    Self.Filters += [b, True];
  end;

  if not Self.IsSetup then
  begin
    Self.Walker.Setup(
      @Self.Position, @Self.Height, @Self.Loader.GetLocal,
      @Self.Loader.Graph, Self.Loader.Map
    );
    Self.Walker.Name := 'Map.Walker';

    Self.IsSetup := True;
  end;
end;


(*
## Map.Setup
```pascal
procedure TRSMap.SetupEx(boxes: TBoxArray; planes: TIntegerArray = [0]; downscale: UInt32 = 8);
procedure TRSMap.Setup(chunks: TRSMapChunkArray; downscale: UInt32 = 8);
procedure TRSMap.Setup(echunks: set of ERSChunk; downscale: UInt32 = 8); overload;
```
Sets up a {ref}`TRSMap`.
*)
procedure TRSMap.SetupEx(boxes: TBoxArray; planes: TIntegerArray = [0]; downscale: UInt32 = 8);
var
  i: Int32;
  chunk: TRSMapChunk;
  chunks: array of TRSMapChunk;
begin
  chunk.Planes := planes;

  for i := 0 to High(boxes) do
  begin
    chunk.Chunk := boxes[i];
    chunks += chunk;
  end;

  Self.Loader.Load(chunks, downscale);
  Self.InternalSetup();
end;

procedure TRSMap.Setup(chunks: TRSMapChunkArray; downscale: UInt32 = 8);
begin
  Self.Loader.Load(chunks, downscale);
  Self.InternalSetup();
end;

procedure TRSMap.Setup(echunks: set of ERSChunk; downscale: UInt32 = 8); overload;
var
  chunks: array of TRSMapChunk;
  echunk: ERSChunk;
begin
  for echunk in echunks do
    chunks += echunk.Get();
  Self.Setup(chunks, downscale);
end;

(*
## Map.Add
```pascal
procedure TRSMap.AddEx(boxes: TBoxArray; planes: TIntegerArray = [0]; downscale: UInt32 = 8);
procedure TRSMap.Add(chunks: TRSMapChunkArray; downscale: UInt32 = 8);
procedure TRSMap.Add(echunks: set of ERSChunk; downscale: UInt32 = 8); overload;
```
TRSMap to add maps to an already setup TRSMap.
*)
procedure TRSMap.AddEx(boxes: TBoxArray; planes: TIntegerArray = [0]; downscale: UInt32 = 8);
var
  i: Int32;
  chunk: TRSMapChunk;
  chunks: array of TRSMapChunk;
begin
  chunk.Planes := planes;

  for i := 0 to High(boxes) do
  begin
    chunk.Chunk := boxes[i];
    chunks += chunk;
  end;

  Self.Loader.Add(chunks, downscale);
  Self.InternalSetup();
end;

procedure TRSMap.Add(chunks: TRSMapChunkArray; downscale: UInt32 = 8);
var
  chunk: TRSMapChunk;
begin
  for chunk in chunks do
    Self.AddEx([chunk.Chunk], chunk.Planes, downscale);
end;

procedure TRSMap.Add(echunks: set of ERSChunk; downscale: UInt32 = 8); overload;
var
  chunks: array of TRSMapChunk;
  echunk: ERSChunk;
begin
  for echunk in echunks do
    chunks += echunk.Get();
  Self.Add(chunks, downscale);
end;


(*
## Map.AutoSetup
```pascal
function TRSMap.AutoSetup(minSimilarity: Single = 0.2; downscale: UInt32 = 8): Boolean;
```
Automatically detects the player's position on the overworld (plane 0) using a two-phase approach:
1. Loads large surface regions at high downscale for quick approximate positioning
2. Refines to the specific chunk for precise positioning

Returns True if position is found with similarity >= minSimilarity.
For dungeons and other planes, use AutoSetupEx instead.

Example:
```pascal
if Map.AutoSetup() then
  WriteLn('Found position: ', Map.Position())
else
  WriteLn('Could not detect position');
```
*)
(*
## Map.AutoSetup
```pascal
function TRSMap.AutoSetup(minSimilarity: Single = 0.2; downscale: UInt32 = 8): Boolean;
```
Automatically detects the player's position using a two-phase approach:
1. Loads a large surface region at high downscale for quick approximate positioning
2. Refines to the specific chunk for precise positioning

Returns True if position is found with similarity >= minSimilarity.

Example:
```pascal
if Map.AutoSetup() then
  WriteLn('Found position: ', Map.Position())
else
  WriteLn('Could not detect position');
```
*)
function TRSMap.AutoSetup(Regions: TBoxArray = [[14,66,63,31]];minSimilarity: Single = 0.3; downscale: UInt32 = 8): Boolean;
const
  PHASE1_DOWNSCALE = 16;
var
  approxPos, chunkCoord: TPoint;
  chunkBox, region: TBox;
  graphWasDisabled: Boolean;
  bestSimilarity: Single;
  bestPos: TPoint;
begin
  //Disable graph generation during auto-detection for speed
  graphWasDisabled := WebGraphGenerator.Disabled;
  WebGraphGenerator.Disabled := True;
  bestSimilarity := 0;

  //Phase 1: Scan regions to find approximate position
  for region in Regions do
  begin
    WriteLn GetDebugLn('Map', 'AutoSetup Phase 1: Scanning region ' + ToStr(region) + '...');
    Self.Loader.Free();
    Self.IsSetup := False;


    Self.SetupEx([region], [0], PHASE1_DOWNSCALE);

    approxPos := Self.Position();

    //Continue;


    WriteLn GetDebugLn('Map', 'AutoSetup region similarity: ' + ToStr(Round(Self.Similarity, 3)));

    if Self.Similarity > bestSimilarity then
    begin
      bestSimilarity := Self.Similarity;
      bestPos := approxPos;
    end;

    //Early exit if we found a good match
    if Self.Similarity >= minSimilarity then
      Break;
  end;

  if bestSimilarity < minSimilarity / 2 then
  begin
    WriteLn GetDebugLn('Map', 'AutoSetup could not find approximate position.', ELogLevel.WARN);
    WebGraphGenerator.Disabled := graphWasDisabled;
    Exit(False);
  end;

  //Phase 2: Convert to chunk coordinates and load specific area
  chunkCoord := RSTranslator.Global2Chunk(bestPos);
  WriteLn GetDebugLn('Map', 'AutoSetup Phase 2: Refining at chunk ' + ToStr(chunkCoord));

  //Create a 3x3 chunk box around the found position
  chunkBox := [chunkCoord.X - 1, chunkCoord.Y - 1, chunkCoord.X + 1, chunkCoord.Y + 1];

  Self.Loader.Free();
  Self.IsSetup := False;

  //Restore graph setting for final setup so walker works
  WebGraphGenerator.Disabled := graphWasDisabled;

  try
    Self.SetupEx([chunkBox], [0], downscale);
    Self.Position();
  except
    WriteLn GetDebugLn('Map', 'AutoSetup Phase 2 failed: ' + GetExceptionMessage(), ELogLevel.WARN);
    Exit(False);
  end;

  WriteLn GetDebugLn('Map', 'AutoSetup Phase 2 similarity: ' + ToStr(Round(Self.Similarity, 3)));

  if Self.Similarity >= minSimilarity then
  begin
    WriteLn GetDebugLn('Map', 'AutoSetup found position at ' + ToStr(Self.Position()));
    Result := True;
  end
  else
  begin
    WriteLn GetDebugLn('Map', 'AutoSetup similarity below threshold.', ELogLevel.WARN);
    Result := False;
  end;
end;


(*
## Map.NeedsExpansion
```pascal
function TRSMap.NeedsExpansion(position: TPoint): Boolean;
```
Checks if the current position is near the edge of loaded map regions
and expansion is needed.
*)
function TRSMap.NeedsExpansion(position: TPoint): Boolean;
var
  localPos: TPoint;
  bounds: TBox;
  threshold: Integer;
begin
  if not Self.DynamicLoading.Enabled then Exit(False);
  if Self.DynamicLoading.Loading then Exit(False);
  if Self.DynamicLoading.Preloading then Exit(False);
  if Length(Self.Loader.Regions) = 0 then Exit(False);

  threshold := Self.DynamicLoading.EdgeThreshold;
  localPos := Self.Loader.GetLocal(Self.RegionIndex, position);
  bounds := Self.Loader.MapBox;

  //Check if near any edge
  Result := (localPos.X < bounds.X1 + threshold) or
            (localPos.X > bounds.X2 - threshold) or
            (localPos.Y < bounds.Y1 + threshold) or
            (localPos.Y > bounds.Y2 - threshold);
end;

(*
## Map.ExpandMap
```pascal
procedure TRSMap.ExpandMap(position: TPoint);
```
Expands the loaded map around the current position by loading adjacent chunks.
*)
procedure TRSMap.ExpandMap(position: TPoint);
var
  chunkCoord: TPoint;
  expandBox: TBox;
  radius: Integer;
  graphWasDisabled: Boolean;
begin
  if Self.DynamicLoading.Loading then Exit;

  Self.DynamicLoading.Loading := True;
  radius := Self.DynamicLoading.ChunkRadius;

  chunkCoord := RSTranslator.Global2Chunk(position);

  //Skip if we already expanded from this chunk
  if chunkCoord = Self.DynamicLoading.LastExpansion then
  begin
    Self.DynamicLoading.Loading := False;
    Exit;
  end;

  expandBox := [
    chunkCoord.X - radius,
    chunkCoord.Y - radius,
    chunkCoord.X + radius,
    chunkCoord.Y + radius
  ];

  //Disable graph generation during expansion for speed
  graphWasDisabled := WebGraphGenerator.Disabled;
  WebGraphGenerator.Disabled := True;

  try
    Self.AddEx([expandBox], [Self.Region.Plane], Self.Loader.Downscale);
    Self.DynamicLoading.LastExpansion := chunkCoord;
  except
    WriteLn GetDebugLn('Map', 'Map expansion failed: ' + GetExceptionMessage(), ELogLevel.WARN);
  end;

  WebGraphGenerator.Disabled := graphWasDisabled;
  Self.DynamicLoading.Loading := False;
end;

(*
## Map._DynamicLoadingWalkEvent
Internal callback for dynamic loading during walking.
*)
procedure TRSMap._DynamicLoadingWalkEvent(walker: PRSWalker; position, destination: TPoint);
begin
  //Call previous event if exists
  if @Self.DynamicLoading.PreviousOnWalkEvent <> nil then
    Self.DynamicLoading.PreviousOnWalkEvent(walker, position, destination);

  //Check and expand if needed
  if Self.NeedsExpansion(position) then
    Self.ExpandMap(position);
end;

(*
## Map.EnableDynamicLoading
```pascal
procedure TRSMap.EnableDynamicLoading(edgeThreshold: Integer = 200; chunkRadius: Integer = 2);
```
Enables dynamic map loading during walking. When the player approaches the edge
of the currently loaded map, adjacent chunks are automatically loaded.

Parameters:
- edgeThreshold: Distance in pixels from edge to trigger loading (default 200)
- chunkRadius: Number of chunks to load around current position (default 2)

Example:
```pascal
Map.AutoSetup();
Map.EnableDynamicLoading();
Map.Walker.WebWalk(destination);
```
*)
procedure TRSMap.EnableDynamicLoading(edgeThreshold: Integer = 200; chunkRadius: Integer = 2);
begin
  Self.DynamicLoading.Enabled := True;
  Self.DynamicLoading.EdgeThreshold := edgeThreshold;
  Self.DynamicLoading.ChunkRadius := chunkRadius;
  Self.DynamicLoading.Loading := False;
  Self.DynamicLoading.Preloading := False;
  Self.DynamicLoading.LastExpansion := [-1, -1];

  //Save and replace walk event
  @Self.DynamicLoading.PreviousOnWalkEvent := @Self.Walker.OnWalkEvent;
  @Self.Walker.OnWalkEvent := @Self._DynamicLoadingWalkEvent;
end;

(*
## Map.DisableDynamicLoading
```pascal
procedure TRSMap.DisableDynamicLoading();
```
Disables dynamic map loading.
*)
procedure TRSMap.DisableDynamicLoading();
begin
  Self.DynamicLoading.Enabled := False;

  //Restore previous walk event
  @Self.Walker.OnWalkEvent := @Self.DynamicLoading.PreviousOnWalkEvent;
  @Self.DynamicLoading.PreviousOnWalkEvent := nil;
end;

(*
## Map.PreloadDirection
```pascal
procedure TRSMap.PreloadDirection(position, destination: TPoint);
```
Preloads chunks in the direction of travel. Call this before walking
to preload the path ahead while you're still setting up.
*)
procedure TRSMap.PreloadDirection(position, destination: TPoint);
var
  chunkPos, chunkDest: TPoint;
  preloadBox: TBox;
  plane: Integer;
  downscale: UInt32;
begin
  Self.DynamicLoading.Preloading := True;

  chunkPos := RSTranslator.Global2Chunk(position);
  chunkDest := RSTranslator.Global2Chunk(destination);

  //Create box covering path from current to destination
  preloadBox := [
    Min(chunkPos.X, chunkDest.X) - 1,
    Min(chunkPos.Y, chunkDest.Y) - 1,
    Max(chunkPos.X, chunkDest.X) + 1,
    Max(chunkPos.Y, chunkDest.Y) + 1
  ];

  WriteLn GetDebugLn('Map', 'PreloadDirection: pos=' + ToStr(position) + ' chunk=' + ToStr(chunkPos));
  WriteLn GetDebugLn('Map', 'PreloadDirection: dest=' + ToStr(destination) + ' chunk=' + ToStr(chunkDest));
  WriteLn GetDebugLn('Map', 'PreloadDirection: loading box=' + ToStr(preloadBox));

  //Save current settings before reload
  plane := Self.Region.Plane;
  downscale := Self.Loader.Downscale;

  //Free and reload everything fresh with webgraph enabled
  //This is needed because AutoSetup loads chunks without webgraph,
  //and AddEx skips already-loaded chunks
  Self.Loader.Free();
  Self.IsSetup := False;

  try
    Self.SetupEx([preloadBox], [plane], downscale);
    Self.DynamicLoading.LastExpansion := chunkPos;
    WriteLn GetDebugLn('Map', 'PreloadDirection: loaded successfully, graph nodes=' + ToStr(Length(Self.Loader.Graph.Nodes)) +
                       ', clusters=' + ToStr(Length(Self.Loader.Graph.WalkableClusters)));
  except
    WriteLn GetDebugLn('Map', 'Preload failed: ' + GetExceptionMessage(), ELogLevel.WARN);
  end;

  Self.DynamicLoading.Preloading := False;
end;

(*
## Map.WalkAndLoad
```pascal
function TRSMap.WalkAndLoad(destination: TPoint; minDist: Integer = 0): Boolean;
```
Walks to destination while dynamically loading chunks as needed.
Combines EnableDynamicLoading with WebWalk for convenience.

Example:
```pascal
Map.AutoSetup();
Map.WalkAndLoad([12500, 11800]);
```
*)
function TRSMap.WalkAndLoad(destination: TPoint; minDist: Integer = 0): Boolean;
var
  wasEnabled: Boolean;
  startPos: TPoint;
begin
  WriteLn GetDebugLn('Map', 'WalkAndLoad: starting, destination=' + ToStr(destination));

  wasEnabled := Self.DynamicLoading.Enabled;

  if not wasEnabled then
    Self.EnableDynamicLoading();

  WriteLn GetDebugLn('Map', 'WalkAndLoad: getting position...');
  startPos := Self.Position();
  WriteLn GetDebugLn('Map', 'WalkAndLoad: position=' + ToStr(startPos));

  //Preload the path ahead with fast graph generation
  Self.PreloadDirection(startPos, destination);

  WriteLn GetDebugLn('Map', 'WalkAndLoad: calling WebWalkEx...');
  //Use WebWalkEx with known startPos - don't call Position() again after map expansion
  //as the expanded map might cause template matching to find wrong position
  Result := Self.Walker.WebWalkEx(startPos, destination, minDist);
  WriteLn GetDebugLn('Map', 'WalkAndLoad: WebWalkEx returned ' + ToStr(Result));

  if not wasEnabled then
    Self.DisableDynamicLoading();
end;


(*
## Map.ScaledSearch
```pascal
function TRSMap.ScaledSearch(img: TImage): TPointArray;
```
Internal TRSMap method used to get an initial TPointArray of possible positions.
This is performed in a downscaled map with a downscaled minimap.
This is very innacurate by itself but by ruling down most of the map
in a downscaled search before doing a full sized search speed has a dramatic boost.
You probably won't ever need to call this directly.
*)
function TRSMap.ScaledSearch(img: TImage): TPointArray;
var
  sample: TImage;
  matrix: TSingleMatrix;
  w, h, i, loops: Integer;
  pt, loaderOffset: TPoint;
  width, height: Integer;
begin
  sample := Minimap.ScaleMinimap(img, Self.Loader.Downscale, Self.Sample.Radius);
  matrix := MatchTemplateMask(Self.Cache.MatchTemplate, sample.ToMatrix(), ETMFormula.TM_CCOEFF_NORMED);

  w := sample.Width div 2;
  h := sample.Height div 2;

  loaderOffset := [Self.Loader.Downscale div 2, Self.Loader.Downscale div 2];
  matrix.GetSize(width, height);
  width -= 1;
  height -= 1;

  while Length(Result) < Self.Sample.Amount do
  begin
    with matrix.ArgMax() do
    begin
      pt := Offset(w, h);
      pt := pt * Self.Loader.Downscale;

      for i := 0 to High(Self.Filters) do
      begin
        if Self.Filters[i].Valid(pt) then
        begin
          Result += pt + loaderOffset;
          matrix.Fill([Max(0, X-5), Max(0, Y-5), Min(width, X+5), Min(height, Y+5)], 0);
          Continue(2);
        end;
      end;

      matrix.Fill([Max(0, X-5), Max(0, Y-5), Min(width, X+5), Min(height, Y+5)], 0);
    end;

    if Inc(loops) > 70 then Break;
  end;
end;

(*
## Map.Position
```pascal
function TRSMap.Position(): TPoint;
property TRSMap.FullPosition(): TRSPosition;
```
Returns the players current position on the loaded map.
`TRSMap.FullPosition()` also returns the current Z level.

Example:
```pascal
WriteLn(Map.Position());
WriteLn(Map.Similarity); // Check to see the match percentage if needed
```
*)
function TRSMap.Position(): TPoint;
const
  SCALE: Integer = 2;
var
  clean, half: TImage;
  results: TPointArray;
  i: Integer;
  hit, center: TPoint;
  angle, match: Single;
begin
  Self.RegionIndex := -1;
  Self.Region := [];
  Self.Similarity := 0;

  angle := Minimap.CompassRadians;
  clean := Minimap.GetCleanImage(angle, Self.Sample.Radius);
  results := Self.ScaledSearch(clean);

  half := Minimap.ScaleMinimap(clean, SCALE, Self.Sample.Radius);
  half := half.Blend(half.FindColor($0, 0), 10);

  for i := 0 to High(results) do
  begin
    hit := TRSImageMap.FullSearch(half, Self.Loader.HalfMap, results[i], SCALE, match);

    if match > Self.Similarity then
    begin
      Self.Similarity := match;
      Result := hit;
    end;
  end;

  center := clean.Center;

  if RSClient.Mode = ERSMode.FIXED then
    center := center.Offset(0, 8).Rotate(-angle, center)
  else
    center := center.Offset(2, 1).Rotate(-angle, center);
  Result := Result.Offset(center);

  Self.Cache.LocalPosition := Result;

  Self.RegionIndex := Self.Loader.LocalIndex(Result);
  if Self.RegionIndex < 0 then
    Exit([0,0]);

  Self.Region := Self.Loader.Regions[Self.RegionIndex];
  Result := RSTranslator.Normalize(Self.Loader.GetGlobal(Self.RegionIndex, Result));
  Self.Cache.Position := Result;
end;

property TRSMap.FullPosition: TRSPosition;
begin
  with Self.Position() do
  begin
    Result.X := X;
    Result.Y := Y;
    Result.Plane := Self.Region.Plane;
    Result.Z := Self.Height([X,Y]);
  end;

  Self.Cache.FullPosition := Result;
end;

function TRSMap.GetRegionIndex(): Int32;
begin
  Self.Position();
  Result := Self.RegionIndex;
end;


(*
## Map.Height
```pascal
function TRSMap.Height(pt: TPoint; global: Boolean = True): Single;
```
Returns the height of the player at the specified coordinate if there's a heightmap loaded.
If `pt` is `[0,0]`, which is the default then we will use our current position.
`global` decides wether the coordinate is converted to {ref}`global points` or if it's meant to be used
as internal {ref}`local points`.

Example:
```pascal
WriteLn Map.Height();
```
*)
function TRSMap.Height(pt: TPoint = [0,0]; global: Boolean = True): Single;
var
  neighbours: TPointArray;
  p: TPoint;
begin
  if Self.DisableHeightmap or not Assigned(Self.Loader.Heightmap) then
    Exit(0.0);

  if pt = [0,0] then
  begin
    global := False;
    Self.Position();
    pt := Self.Cache.LocalPosition;
  end;

  if global then
    pt := Self.Loader.GetLocal(Self.RegionIndex, pt);

  neighbours := [
    pt, pt.Offset(-1,-1), pt.Offset(1,-1), pt.Offset(-1,1),  pt.Offset(1,1)
  ];

  for p in neighbours do
  begin
    if Self.Loader.Heightmap.InImage(p.X, p.Y) then
      Result += RSTranslator.Color2Height(Self.Loader.Heightmap.Pixel[p.X,p.Y])
    else if Self.Loader.Heightmap.InImage(pt.X, pt.Y) then
      Result += RSTranslator.Color2Height(Self.Loader.Heightmap.Pixel[pt.X,pt.Y]);
  end;

  Result := Result/Length(neighbours);
end;


function TRSMap.GetQuad(me, pt: TPoint; angle: Single = $FFFF): TQuad;
var
  vector: TVector2;
  corners: TVector3Array;
  h: Single;
  currLoc: TPoint;
  arr: TPointArray;
begin
  if angle = $FFFF then angle := Minimap.CompassRadians;
  vector := Self.Walker.Point2MMVec(me, pt, angle);
  pt := vector.ToPoint();

  if not Minimap.PointOnZoomQuad(pt) then Exit;

  vector := Minimap.NormalizeEx(vector, angle);
  me := Self.Loader.GetLocal(me);

  h := Self.Height(me, False);

  currLoc := me + vector.ToPoint() - Minimap.Center;

  corners := [
    [vector.X-2, vector.Y-2, Self.Height(currLoc + [-1,-1], False) - h],
    [vector.X+2, vector.Y-2, Self.Height(currLoc + [1,-1],  False) - h],
    [vector.X+2, vector.Y+2, Self.Height(currLoc + [1,1],   False) - h],
    [vector.X-2, vector.Y+2, Self.Height(currLoc + [-1,1],  False) - h]
  ];

  arr := Projection.Run(corners, angle);
  Result := [arr[0], arr[1], arr[2], arr[3]];
end;


(*
## Map.DebugPosition
```pascal
function TRSMap.DebugPosition(): TPoint;
```
Debugs the player position in the currently loaded map.

Example:
```pascal
Map.Setup(...);
while True do
  Map.DebugPosition();
```
*)
function TRSMap.DebugPosition(print: Boolean = True): TPoint;
  function _BoxStr(b: TBox): String;
  begin
    Result := Format('[%d, %d, %d, %d]', [b.X1, b.Y1, b.X2, b.Y2]);
  end;
var
  x1, y1, x2, y2, x, y, i: Int32;
  p, local: TPoint;
  img, map, cleanMinimap: TImage;
  time: Double;
  lines: TStringArray;
begin
  Target.FreezeImage();

  time   := PerformanceTime();
  Result := Self.Position();

  time   := PerformanceTime() - time;

  case Self.RegionIndex of
    -1:  local := Result;
    else
    begin
      local := Self.Loader.GetLocal(Self.RegionIndex, Result);
      x := Self.Region.Region.X1;
      y := Self.Region.Region.Y1;
    end;
  end;

  x1 := Max(0, local.X - 200);
  y1 := Max(0, local.Y - 200);
  x2 := Min(x1 + 400, Self.Loader.Map.Width  - 1);
  y2 := Min(y1 + 400, Self.Loader.Map.Height - 1);

  x := local.X - x1;
  y := local.Y - y1;

  lines := [
    'Position:',
    ' - Local : '  + Format('[%d, %d]', [local.X, local.Y]),
    ' - Global: ' + Format('[%d, %d]', [Result.X, Result.Y]),
    '',
    'Region:',
    ' - Index   : ' + ToStr(Self.RegionIndex),
    ' - Name    : ' + ToStr(Self.Region.Name),
    ' - Plane   : ' + ToStr(Self.Region.Plane),
    ' - Local   : ' + _BoxStr(Self.Region.Region),
    ' - Original: ' + _BoxStr(Self.Region.Original),
    ' - Compass: '  + ToStr(Minimap.CompassDegrees),
    '',
    'Certainty: '    + ToStr(Round(Self.Similarity, 3)),
    'Time: '         + ToStr(Round(time)) + ' ms'
  ];

  map := Self.Loader.Map.Copy([x1, y1, x2, y2]);
  map.DrawColor := $00FF00;
  map.DrawLine(Point(0, y), Point(x2 - x1, y));
  map.DrawLine(Point(x, 0), Point(x, y2 - y1));
  map.DrawColor := $FFFFFF;
  map.DrawBox([x - 2, y - 2, x + 2, y + 2]);

  cleanMinimap := Minimap.GetCleanImage();
  img := new TImage(700 + cleanMinimap.Width, 440);
  img.DrawImage(map, [10, 20]);

  with cleanMinimap.Center do
  begin
    if RSClient.Mode = ERSMode.FIXED then
      p := Point(X, Y).Offset(0, 8).Rotate(-Minimap.CompassRadians, [X,Y])
    else
      p := Point(X, Y).Offset(2, 1).Rotate(-Minimap.CompassRadians, [X,Y]);
  end;

  cleanMinimap.DrawColor := $FFFFFF;
  cleanMinimap.DrawBox(TBox.Create(p, 1, 1));
  cleanMinimap.DrawColor := $FF;
  cleanMinimap.DrawCross(p, 4);

  {$IFDEF WINDOWS}
  img.FontName := 'Consolas';
  {$ENDIF}
  img.FontSize := 18;
  img.FontAntialiasing := True;

  img.DrawColor := $FFFFFF;
  for i := 0 to High(lines) do
  begin
    if print then WriteLn(lines[i]);
    img.DrawText(lines[i], [430, cleanMinimap.Height + 20 + 20 * i]);
  end;

  img.DrawImage(cleanMinimap, [520, 10]);
  img.Show();

  Target.UnFreezeImage();
end;

(*
## Map.DebugHeight
```pascal
procedure TRSMap.DebugHeight(img: TImage; dots: ERSMinimapDots);
procedure TRSMap.DebugHeight(dots: ERSMinimapDots = [ERSMinimapDot.PLAYER..ERSMinimapDot.ITEM]); overload;
```
Debugs the heightmap with {ref}`MM2MS`.

Example:
```pascal
{$I WaspLib/osrs.simba}
begin
  Map.Setup([ERSChunk.VARROCK]);
  while True do
  begin
    Options.GetZoomLevel(False);
    Map.DebugHeight();
  end;
end.
```

```{figure} ../../images/mm2ms_height.gif
```
*)
procedure TRSMap.DebugHeight(img: TImage; dots: ERSMinimapDots);
const
  DOT_COLORS: TColorArray = [$FFFFFF, $00FFFF, $0000FF];
var
  quad: TQuad;
  arr, tpa: TPointArray;
  pt, q, loc, currLoc: TPoint;
  x,y: Integer;
  vector: TVector3;
  corners: TVector3Array;
  angle, h: Single;
  dot: ERSMinimapDot;
begin
  angle := Minimap.CompassRadians;

  img.DrawColor := $00FF00;
  img.DrawAlpha := $FF;

  Self.Position();
  loc := Self.Cache.LocalPosition;
  h := RSTranslator.Color2Height(Self.Loader.Heightmap.Pixel[loc.X,loc.Y]);

  for x := Minimap.Center.X - 120 to Minimap.Center.X + 120 with 4 do
    for y := Minimap.Center.Y - 120 to Minimap.Center.Y + 120 with 4 do
    begin
      vector := Point(x,y).ToVec3().Rotate(angle, Minimap.Center);
      pt := vector.ToPoint();

      if not Minimap.PointOnZoomQuad(pt) then Continue;

      with Minimap.NormalizeEx([vector.X, vector.Y], angle) do
      begin
        vector.X := X;
        vector.Y := Y;
      end;

      currLoc := loc + Point(x,y) - Minimap.Center;

      corners := [
        [vector.X-2, vector.Y-2, Self.Height(currLoc + [-1,-1], False) - h],
        [vector.X+2, vector.Y-2, Self.Height(currLoc + [1,-1],  False) - h],
        [vector.X+2, vector.Y+2, Self.Height(currLoc + [1,1],   False) - h],
        [vector.X-2, vector.Y+2, Self.Height(currLoc + [-1,1],  False) - h]
      ];

      arr := Projection.Run(corners, angle);
      quad := [arr[0], arr[1], arr[2], arr[3]];
      tpa += quad.Corners.Connect();
    end;

  img.DrawTPA(MainScreen.Filter(tpa));

  for dot in dots do
  begin
    tpa := [];
    for q in Minimap.GetDots(dot) do
    begin
      vector := q.ToVec3();
      pt := vector.ToPoint();

      if not Minimap.PointOnZoomQuad(pt) then Continue;

      with Minimap.NormalizeEx([vector.X, vector.Y], angle) do
      begin
        vector.X := X;
        vector.Y := Y;
      end;

      currLoc := loc + q - Minimap.Center;

      corners := [
        [vector.X-2, vector.Y-2, Self.Height(currLoc - [1,3],  False) - h],
        [vector.X+2, vector.Y-2, Self.Height(currLoc + [3,-3], False) - h],
        [vector.X+2, vector.Y+2, Self.Height(currLoc + [3,1],  False) - h],
        [vector.X-2, vector.Y+2, Self.Height(currLoc - [1,1],  False) - h]
      ];

      arr := Projection.Run(corners, angle);
      quad := [arr[0], arr[1], arr[2], arr[3]];
      tpa += quad.Corners.Connect();
    end;

    img.DrawColor := DOT_COLORS[dot];
    img.DrawTPA(MainScreen.Filter(tpa));
  end;
end;

procedure TRSMap.DebugHeight(dots: ERSMinimapDots = [ERSMinimapDot.PLAYER..ERSMinimapDot.ITEM]); overload;
var
  img: TImage;
begin
  img := Target.GetImage();
  Self.DebugHeight(img, dots);
  img.Show();
end;


var
(*
## Map variable
Global {ref}`TRSMap` variable.
*)
  Map: TRSMap;

