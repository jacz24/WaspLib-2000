(*
# RSObjects
This page is about {ref}`RSObjects` which are an interface for interacting with
game objects.
*)

{$DEFINE WL_RSOBJECTS_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
  EObjectData = enum(ID, NAME, TYP, CATEGORY, ACTIONS, COORDINATES, SIZE, ROTATIONS, COLORS);

(*
## TRSObject
Main type to handle {ref}`RSObjects`.
*)
  TRSObject = record
    UpText: TStringArray;
    Size: TVector3;
    Model: TModel;
    Coordinates: TPointArray;
    LastCoordinate: TPoint;
    Rotations: TIntegerArray;
    Finder: TColorFinder;
    Track: Boolean;
    Walker: PRSWalker;
  end;

(*
## TRSObjectArray
Array of {ref}`TRSObject`.
*)
  TRSObjectArray = array of TRSObject;

(*
## RSObject.Create
```pascal
function TRSObject.Create(walker: PRSWalker; size: TVector3; coordinates: TPointArray; uptext: TStringArray = []): TRSObject; static;
function TRSObject.Create(json: TJSONObject): TRSObject; static; overload;
```
Createors to create your {ref}`TRSObject`.

Assuming you create the `RSObject` manually, the Createor will provide you
with a fully built `TRSObject` without a finder.

You may optionally assign one later if you want:
```pascal
{$I WaspLib/osrs.simba}
var
  obj: TRSObject;
begin
  Map.Setup([ERSChunk.VARROCK]);
  obj := TRSObject.Create(@Map.Walker, [1,1,7], [[8648,36686]], ['Bank booth']);
  //obj.Finder.Colors += $FFFFFF;
end;
```

The `json` version of the function expects a specific json structure which is
the one that {ref}`Map JSONs` provide:
```pascal
{$I WaspLib/osrs.simba}
var
  obj: TRSObject;
begin
  Map.Setup([ERSChunk.VARROCK]);
  //Item[0] because this returns a JSON array. For more info read Map JSONs documentation.
  obj := TRSObject.Create(ObjectsJSON.GetByName('bank', 1).Item[0]);
end;
```
*)
function TRSObject.Create(walker: PRSWalker; size: TVector3; coordinates: TPointArray; uptext: TStringArray = []): TRSObject; static;
begin
  Result.Coordinates := coordinates;
  SetLength(Result.Rotations, Length(coordinates));
  Result.Size := size;
  if uptext <> [] then
    Result.UpText := uptext;
  Result.Walker := walker;
end;

function TRSObject.Create(json: TJSONObject): TRSObject; static; overload;
var
  i, j, l: Integer;
  unique: array of TColorArray;
  color: TColor;
  best: TBestColor;
begin
  if json.Typ <> EJSONType.OBJ then
    raise GetDebugLn('TRSObject', 'JSON Object expected, got ' + ToStr(json.Typ) + '.');

  with json.Item[Ord(EObjectData.NAME)] do
    if AsString <> 'null' then
      Result.UpText := [AsString];

  with json.Item[Ord(EObjectData.COORDINATES)] do
    for i := 0 to Count-1 do
      Result.Coordinates += [Item[i].Item[0].AsInt, Item[i].Item[1].AsInt];

  with json.Item[Ord(EObjectData.SIZE)] do
  begin
    Result.Size.X := Item[0].AsInt * 0.8;
    Result.Size.Y := Item[1].AsInt * 0.8;
    Result.Size.Z := Item[2].AsInt / 128;
  end;

  if Abs(Result.Size.Z) < 0.05 then
    Result.Size.Z := 3.0;

  with json.Item[Ord(EObjectData.ROTATIONS)] do
    for i := 0 to Count-1 do
      Result.Rotations += Item[i].AsInt;

  SetLength(Result.Rotations, Length(Result.Coordinates));

  with json.Item[Ord(EObjectData.COLORS)] do
    for i := 0 to Count-1 do
    begin
      color := Item[i].AsInt;

      for j := 0 to High(unique) do
      begin
        for l := 0 to High(unique[j]) do
          if ColorDistance(color, unique[j, l], EColorSpace.HSL, [1.5, 1.5, 1.5]) < 15 then
          begin
            unique[j] += color;
            Continue(3);
          end;
      end;

      unique += [color];
    end;

  for i := 0 to High(unique) do
  begin
    best := GetBestColor(EColorSpace.HSL, unique[i]);
    Result.Finder.Colors += [best.Color, best.Tolerance*1.5, EColorSpace.HSL, [best.Mods[0]*1.5, best.Mods[1]*1.5, best.Mods[2]*1.5]];
  end;

  Result.Walker := @Map.Walker;
end;

(*
## RSObjectArray.Create
```pascal
function TRSObjectArray.Create(json: TJSONArray): TRSObjectArray; static; overload;
```
Create function to build your {ref}`TRSObjectArray`.

This only accepts a `json` array and it expects a specific json structure which is
the one that {ref}`Map JSONs` provide.

Example:
```pascal
{$I WaspLib/osrs.simba}

var
  objs: TRSObjectArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  objs := TRSObjectArray.Create(ObjectsJSON.GetByName('Bank booth')); 
end;
```
*)
function TRSObjectArray.Create(json: TJSONArray): TRSObjectArray; static;
var
  i: Integer;
begin
  if json.Typ <> EJSONType.ARR then
    raise GetDebugLn('TRSObject', 'JSON Array expected, got ' + ToStr(json.Typ) + '.');

  SetLength(Result, json.Count);
  for i := 0 to High(Result) do
    Result[i] := TRSObject.Create(json.Item[i]);
end;

(*
## RSObject.Rotation
```pascal
TRSObject.Rotations: TIntegerArray;
```
`Rotations` allows you to customize the rotation of a `TRSObject`.
By default unless you used {ref}`ObjectsJSON` to create your object they will
no rotation set, AKA `0`.

It's very important that `Rotations` is the same length as `Coordinates` as they
complement each other, each coordinate needs to have a rotation value.

The rotation you want o set should be the respective angle of the object rotated
on it's center:
```pascal
{$I WaspLib/osrs.simba}
var
  furnace: TRSObject;
begin
  Map.Setup([ERSChunk.FALADOR]);
  furnace := TRSObject.Create(@Map.Walker, [2, 3, 6], [[7810, 36954]], ['Furnace']);
  while True do
  begin
    furnace.Rotations[0] += 1;
    ShowOnTarget(furnace);
  end;
end.
```
```{figure} ../../images/obj_rotation.gif
```
*)


(*
## RSObject._GetBounds
```pascal
function TRSObject._GetBounds(me: TPoint; vector: TVector2; size: TVector3; height, radians: Single): TCuboid;
```
Internal helper function for {ref}`TRSObject.GetBoundsArray`.
*)
function TRSObject._GetBounds(me: TPoint; vector: TVector2; size: TVector3; height, radians, rotation: Single): TPolygon;
var
  corners: TVector3Array;
  pt: TPoint;
begin
  pt := me + vector.ToPoint() - Minimap.Center;
  if Self.Model <> nil then
    Exit(Self.Model.GetArea(Self.Model.Project(vector.ToVec3(Self.Walker^.Height(pt, False) - height), rotation, radians)));

  size.X := size.X*2;
  size.Y := size.Y*2;

  corners := [
    [vector.X-size.X, vector.Y-size.Y, Self.Walker^.Height(pt - [1,3],  False) - height],
    [vector.X+size.X, vector.Y-size.Y, Self.Walker^.Height(pt + [3,-3], False) - height],
    [vector.X+size.X, vector.Y+size.Y, Self.Walker^.Height(pt + [3,1],  False) - height],
    [vector.X-size.X, vector.Y+size.Y, Self.Walker^.Height(pt - [1,1],  False) - height],
    [vector.X-size.X, vector.Y-size.Y, Self.Walker^.Height(pt - [1,3],  False) - height+size.Z],
    [vector.X+size.X, vector.Y-size.Y, Self.Walker^.Height(pt + [3,-3], False) - height+size.Z],
    [vector.X+size.X, vector.Y+size.Y, Self.Walker^.Height(pt + [3,1],  False) - height+size.Z],
    [vector.X-size.X, vector.Y+size.Y, Self.Walker^.Height(pt - [1,1],  False) - height+size.Z]
  ];

  Result := Projection.Run(corners, radians).ConvexHull();
end;

(*
## RSObject.GetBoundsArray
```pascal
function TRSObject.GetBoundsArray(me: TPoint; angle: Single = $FFFF): TCuboidArray;
```
Internal function that returns an array of cuboids of the object if it's
coordinates are visible on the {ref}`MainScreen`.

Example:
```pascal
{$I WaspLib/osrs.simba}

var
  objs: TRSObjectArray;
  cuboids: TCuboidArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  objs := TRSObjectArray.Create(ObjectsJSON.GetByAction('Bank'));
  cuboids := objs[1].GetBoundsArray(Map.Position());
  ShowOnTarget(cuboids);
end.
```

```{figure} ../../images/objs_cuboids.png
```
*)
function TRSObject.GetBoundsArray(me: TPoint; out coordinates: TPointArray; radians: Single): TPolygonArray;
var
  weights: TDoubleArray;
  meLocal, pt: TPoint;
  i: Integer;
  h, dist: Double;
  vector: TVector2;
begin
  coordinates := [];
  meLocal := Self.Walker^.GetLocal(me);

  h := Self.Walker^.Height(meLocal, False);

  for i := 0 to High(Self.Coordinates) do
  begin
    pt := Self.Coordinates[i];
    dist := me.DistanceTo(pt);
    if dist > 85 then
      Continue;

    weights += dist;
    coordinates += pt;

    vector := Self.Walker^.Point2MMVec(me, pt, radians);
    pt := vector.ToPoint();
    vector := vector.Rotate(-radians, Minimap.Center);

    Result += Self._GetBounds(meLocal, vector, Self.Size, h, radians, DegToRad(Self.Rotations[i]));
  end;

  if Result <> [] then
  begin
    Sort(Result, weights, True);
    coordinates.Sort(weights, True);
  end;
end;


(*
## RSObject.FindOnMainScreen
```pascal
function TRSObject.FindOnMainScreen(cuboidArray: TCuboidArray): T2DPointArray;
```
Internal TRSObject method responsible for filtering a TCuboidArray by what's
visible in the mainscren.

This is meant to filter {ref}`TRSObject.GetBoundsArray` so targets that are
outside of the mainscreen are filtered out.

You will probably never need to use this directly.
*)
function TRSObject.FindOnMainScreen(out coordinates: TPointArray; boundsArray: TPolygonArray): T2DPointArray;
var
  i: Integer;
  found: TBooleanArray;
begin
  if Self.Finder <> Default(TColorFinder) then
  begin
    Self.Finder.FindEx(Result, found, boundsArray, Self.Model = nil);

    for i := High(found) downto 0 do
      if not found[i] then
        Delete(coordinates, i, 1);

    Exit;
  end;

  if Self.Model <> nil then
    Exit(boundsArray);

  for i := 0 to High(boundsArray) do
    Result += TPointArray(boundsArray[i]).Connect().ShapeFill();
end;


(*
## RSObject.FindEx
```pascal
function TRSObject.FindEx(me: TPoint; out boundsArray: TPolygonArray; out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
```
Internal {ref}`TRSObject` method used to find a {ref}`RSObject`.
If found returns true, if not returns false.

You also have {ref}`RSObject.Find` to find objects, this version of the method
is internal because it returns extra information about the found objects for
internal use, like it's `cuboids` for example.

This also returns an `atpa` containing the colors of the object that were found
assuming the object has a {ref}`TColorFinder` setup.
If not, the cuboids area are returned as the match.

This extra information is easy to see when you debug your object with
`ShowOnTarget(TRSObject)`:
```pascal
{$I WaspLib/osrs.simba}

var
  objs: TRSObjectArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  objs := TRSObjectArray.Create(ObjectsJSON.GetByAction('Bank'));
  ShowOnTarget(objs[1]);
end.
```

```{figure} ../../images/objs_showontarget.png
```

As you can see, this image is very similar to the one in
{ref}`RSObject.GetBoundsArray`, they differ however in the fact that this one,
aside from the cuboids also shows the object colors that were found within
the cuboids.

This object colors is what's returned through the `atpa` and is what would be
clicked if you use {ref}`RSObject.Click` for example.

Assuming your `RSObject`does not have a {ref}`TColorFinder` setup, this is what
it would look like:
```pascal
{$I WaspLib/osrs.simba}

var
  objs: TRSObjectArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  objs := TRSObjectArray.Create(ObjectsJSON.GetByAction('Bank'));
  objs[1].Finder := []; //removing the finder for this example.
  ShowOnTarget(objs[1]);
end.
```

```{figure} ../../images/objs_nofinder.png
```
*)
function TRSObject.FindEx(me: TPoint; out boundsArray: TPolygonArray; out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
begin
  boundsArray := Self.GetBoundsArray(me, coordinates, Minimap.CompassRadians);
  if boundsArray = [] then Exit;
  atpa := Self.FindOnMainScreen(coordinates, boundsArray);
  Result := atpa <> [];
end;


(*
## RSObject.Find
```pascal
function TRSObject.Find(out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
function TRSObject.Find(out atpa: T2DPointArray): Boolean; overload;
```
{ref}`TRSObject` method used to find a {ref}`RSObject`.
This returns True/False if the object was found and it's `atpa` which cointains
the colors of it that were found.

For more information on this refer to {ref}`RSObject.FindEx`, it's an internal
function but is used within this one and will go into more detail.
*)
function TRSObject.Find(out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
var
  boundsArray: TPolygonArray;
begin
  Result := Self.FindEx(Self.Walker^.Position(), boundsArray, coordinates, atpa);
end;

function TRSObject.Find(out atpa: T2DPointArray): Boolean; overload;
var
  coordinates: TPointArray;
  boundsArray: TPolygonArray;
begin
  Result := Self.FindEx(Self.Walker^.Position(), boundsArray, coordinates, atpa);
end;


(*
## RSObject.FindFrom
```pascal
function TRSObject.FindFrom(position: TPoint; out atpa: T2DPointArray): Boolean;
```
This is similar to {ref}`RSObject.Find` but differs from it in that you can set
your `position`.

This is only useful when you want to predict an object position as if you were
somewhere else you are not.

What you use this for is up to you but an example use case is to pre-hover
objects before you reach a `position` you know you will be at in the future.

For example, imagine a slow agility obstacle on an agility course. Imagine you
want to click the obstacle and hover the next. You know where you will be after
you get through the current obstacle so you can use this to set your `position`
to where you will be after the current obstacle and hover the next one:
```pascal
{$I WaspLib/osrs.simba}

var
  objs: TRSObjectArray;
  atpa: T2DPointArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  objs := TRSObjectArray.Create(ObjectsJSON.GetByAction('Bank'));
  objs[1].Finder := [];

  while True do
  begin
    ShowOnTarget(atpa);
    objs[1].FindFrom([8912,36742], atpa);
  end;
end.
```

```{figure} ../../images/obj_findfrom.gif
```
As you can see on the gif above, the objects debug match the object exactly when
you are at the right coordinate.

For this I also recommend to not have a `TColorFinder` setup because it will
only match when you are at the right position.
*)
function TRSObject.FindFrom(position: TPoint; out atpa: T2DPointArray): Boolean;
var
  boundsArray: TPolygonArray;
  coordinates: TPointArray;
begin
  Result := Self.FindEx(position, boundsArray, coordinates, atpa);
end;

(*
## RSObject._UpTextCheck
```pascal
function TRSObject._UpTextCheck(out shouldExit: Boolean; action: TStringArray): Boolean;
```
Internal `TRSObject` helper method that is used by all hovering methods.

You probably don't need to use this directly.
*)
function TRSObject._UpTextCheck(out shouldExit: Boolean; action: TStringArray): Boolean;
var
  text: String;
begin
  shouldExit := True;

  if (RSClient.Mode = ERSMode.FIXED) and MSInterface.IsOpen() then
    Exit;

  if Self.UpText <> [] then
    Self.Walker^.TargetUpText := Copy(Self.UpText);

  text := MainScreen.UpText;

  if text.Contains('>') and not action.Contains(['>']) then
  begin
    ChooseOption.Close();
    Exit;
  end;

  if not Self.UpText.IsEmpty and text.ContainsAny(Self.UpText) then
    Exit(True);

  shouldExit := False;
end;


(*
## RSObject.PreHover
```pascal
function TRSObject.PreHover(me: TPoint; attempts: Integer = 2): Boolean;
```
To understand what this does it's recommended to read {ref}`RSObject.FindFrom`.

This method basically uses {ref}`RSObject.FindFrom` and moves the
mouse to one of the matches.
*)
function TRSObject.PreHover(me: TPoint; attempts: Integer = 2): Boolean;
var
  attempt: Integer;
  atpa: T2DPointArray;
begin
  for attempt := 0 to attempts do
  begin
    if not Self.FindFrom(me, atpa) then Continue;
    Mouse.Move(atpa.Random().Random());
    Exit(True);
  end;
end;


(*
## RSObject._ClickHelper
```pascal
function TRSObject._ClickHelper(leftClick: Boolean): Boolean;
```
Internal `TRSObject` helper method that is used by other clicking methods.
You probably don't need to use this directly.

This is what's responsible for deciding if we click a target we are hovering or
not.
*)
function TRSObject._ClickHelper(leftClick: Boolean): Boolean;
begin
  if Self.Walker^.RedClicked then
  begin
    Self.Walker^.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Select(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
    Exit;
  end;

  if leftClick and Biometrics.RedClick(EMouseButton.LEFT, 2) then
    Exit(True);

  Result := not leftClick and (Self.UpText <> []) and ChooseOption.Select(Self.UpText);
end;

(*
## RSObject._SelectHelper
```pascal
function TRSObject._SelectHelper(action: TStringArray): Boolean;
```
Internal TRSObject helper method that is used by other select methods.

You probably don't need to use this directly.

This is what is responsible for deciding if we just left click a target we are
hovering or right click it and choose an option.
*)
function TRSObject._SelectHelper(action: TStringArray): Boolean;
begin
  if Self.Walker^.RedClicked then
  begin
    Self.Walker^.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() and ChooseOption.Select(action) then
    Exit(True);

  if MainScreen.IsUpText(action) then
    Exit(Biometrics.RedClick(EMouseButton.LEFT, 2));

  Result := ChooseOption.Select(action);
end;


(*
## RSObject.Hover
```pascal
function TRSObject.Hover(action: TStringArray = []; attempts: Integer = 2): Boolean;
```
Method used to hover a TRSObject target if it's found on the mainscreen.

Example:
```pascal
{$I WaspLib/osrs.simba}

var
  objs: TRSObjectArray;
  atpa: T2DPointArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  objs := TRSObjectArray.Create(ObjectsJSON.GetByAction('Bank'));
  objs[1].Hover();
end.
```

```{figure} ../../images/obj_hover.gif
```
*)
function TRSObject.Hover(action: TStringArray = []; attempts: Integer = 2): Boolean;
var
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  tpa: TPointArray;
  coordinates: TPointArray;
begin
  if ChooseOption.IsOpen() then
  begin
    if ((Self.UpText <> []) or (action <> [])) and ChooseOption.Find(Self.UpText + action) then
      Exit(True);
    ChooseOption.Close();
  end;

  if Self.Walker = nil then
    raise GetDebugLn('TRSObject', 'Walker pointer missing.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSObject', 'Coordinates missing.');
  if Length(Self.Coordinates) <> Length(Self.Rotations) then
    raise GetDebugLn('TRSObject', 'Coordinates and Rotations don''t match.');

  //TODO:
  //if not Self.Walker^.MakePointVisible(Self.Coordinates) then Exit;

  Result := Self._UpTextCheck(shouldExit, action);
  if shouldExit then
    Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText + action) then Exit(True);

    if attempt <> (attempts - 1) then
      Continue;

    Minimap.CompassRadians := Minimap.CompassRadians + PI/3.6 * Random(-1,1);
  end;
end;

(*
## RSObject.WalkHover
```pascal
function TRSObject.WalkHover(action: TStringArray = []; attempts: Integer = 2): Boolean;
```
Method used to walk towards and hover a `TRSObject` target if it's found on the
mainscreen.

Example:
```pascal
{$I WaspLib/osrs.simba}

var
  objs: TRSObjectArray;
  atpa: T2DPointArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  objs := TRSObjectArray.Create(ObjectsJSON.GetByAction('Bank'));
  objs[1].WalkHover();
end.
```

```{figure} ../../images/obj_walkhover.gif
```

In the gif above the function exited true before we finished walking
which is why it's not hovering the bank after we finished walking.

The way this works is that if we successfully hover the bank while walking
it returns true.
*)
function TRSObject.WalkHover(action: TStringArray = []; attempts: Integer = 2): Boolean;
var
  me, closest: TPoint;
  coordinates, tpa: TPointArray;
  path: TGraphNodeArray;
  hasPath: Boolean;
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
begin
  if ChooseOption.IsOpen() then
  begin
    if ((Self.UpText <> []) or (action <> [])) then
      if ChooseOption.Find(Self.UpText + action) then
        Exit(True);
    ChooseOption.Close();
  end;

  me :=  Self.Walker^.Position();
  closest := Self.Walker^.GetClosestPoint(me, Self.Coordinates, path);

  //if the point is not reachable with the webgraph (like a banker behind a booth) then pick nearest node as target
  if path = [] then
  begin
    path := Self.Walker^.WebGraph^.PathToNear(me, closest, 0.33);
    if path = [] then
      raise GetDebugLn('TRSObject', 'Can''t path to object.');
    hasPath := True;
  end;


  Self.Walker^.TargetUpText := Copy(Self.UpText);
  Self.Walker^.ActionUpText := action;

  try
  //check if doors need to be passed to reach target
    if hasPath or Self.Walker^.WebGraph^.WalkableClusters.InSameTPA(me, closest) then
    begin
      if not Self.Walker^.MakePointVisible(closest) and not Self.Walker^.WebWalkEx(me, closest, 32, 0.33) then
        Exit;
    end
    else
    if not Self.Walker^.WebWalk(closest, 32, 0.33) then
      Exit;

    Result := Self._UpTextCheck(shouldExit, action) or Self.Walker^.RedClicked;
    if shouldExit then Exit;

    for attempt := 0 to attempts do
    begin
      if Self.Find(coordinates, atpa) then
      begin
        if attempt < 2 then i := 0
        else if Length(atpa) > (attempt - 2) then i := attempt - 2
        else i := Random(Low(atpa), High(atpa));

        tpa := atpa[i];
        Self.LastCoordinate := coordinates[i];

        Mouse.Move(tpa.RandomMean());

        if Self.UpText = [] then
          Exit(True);
        Sleep(50); //give uptext 1~ frame time to update
      end;

      if MainScreen.IsUpText(Self.UpText + action) then
        Exit(True);

      me := Self.Walker^.Position();
      closest := Self.Walker^.GetClosestPoint(me, Self.Coordinates, path);

      if path = [] then
      begin
        path := Self.Walker^.WebGraph^.PathToNear(me, closest, 0.33);
        if path = [] then
          raise GetDebugLn('TRSObject', 'Can''t path to object.');
      end;

      if me.DistanceTo(closest) > 50 then
      begin
        Self.Walker^.WebWalkEx(me, closest, 30, 0.15);
        Continue;
      end;

      if attempt <> (attempts - 1) then Continue;

      if me.DistanceTo(closest) > 25 then
      begin
        Self.Walker^.WebWalkEx(me, closest, 25, 0.15);
        Continue;
      end;

      Minimap.CompassRadians := Minimap.CompassRadians + PI/3.6 * Random(-1,1);
    end;
  finally
    Self.Walker^.TargetUpText := [];
    Self.Walker^.ActionUpText := [];
  end;
end;


(*
## RSObject.Click
```pascal
function TRSObject.Click(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
```
Method used to click a `TRSObject` target if it's found on the mainscreen.

Example:
```pascal
{$I WaspLib/osrs.simba}

var
  objs: TRSObjectArray;
  atpa: T2DPointArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  objs := TRSObjectArray.Create(ObjectsJSON.GetByAction('Bank'));
  objs[1].Click();
end.
```

```{figure} ../../images/obj_click.gif
```
*)
function TRSObject.Click(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
begin
  Result := Self.Hover([], attempts) and Self._ClickHelper(leftClick);
end;

(*
## RSObject.Interact
```pascal
function TRSObject.Interact(action: TStringArray; attempts: Integer = 2): Boolean;
```
Method used to select an option on a `TRSObject` target if it's found on the
mainscreen.

Through `action` you can specify the interaction you are looking for.
If this interaction is the uptext when you hover the object WaspLib will simply
left click it.

Example:
```pascal
{$I WaspLib/osrs.simba}

var
  objs: TRSObjectArray;
  atpa: T2DPointArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  objs := TRSObjectArray.Create(ObjectsJSON.GetByAction('Bank'));
  objs[1].Interact(['Collect']);
end.
```

```{figure} ../../images/obj_select.gif
```
*)
function TRSObject.Interact(action: TStringArray; attempts: Integer = 2): Boolean;
begin
  Result := Self.Hover(action, attempts) and Self._SelectHelper(action);
end;


(*
## RSObject.WalkClick
```pascal
function TRSObject.WalkClick(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
```
Method used to walk towards and click a `TRSObject` target if it's found on the
mainscreen.

Example:
```pascal
{$I WaspLib/osrs.simba}

var
  objs: TRSObjectArray;
  atpa: T2DPointArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  objs := TRSObjectArray.Create(ObjectsJSON.GetByAction('Bank'));
  objs[1].WalkClick();
end.
```

```{figure} ../../images/obj_walkclick.gif
```
*)
function TRSObject.WalkClick(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
begin
  if Self.Walker = nil then
    raise GetDebugLn('TRSObject', 'Walker pointer missing.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSObject', 'Coordinates missing.');
  if Length(Self.Coordinates) <> Length(Self.Rotations) then
    raise GetDebugLn('TRSObject', 'Coordinates and Rotations don''t match.');

  Result := Self.WalkHover([], attempts) and Self._ClickHelper(leftClick);
end;

(*
## RSObject.WalkInteract
```pascal
function TRSObject.WalkInteract(action: TStringArray; attempts: Integer = 2): Boolean;
```
Method used to walk towards and select an option on a `TRSObject` target if it's
found on the mainscreen.

Through `action` you can specify the interaction you are looking for.
If this interaction is the uptext when you hover the object WaspLib will simply
left click it.

Example:
```pascal
{$I WaspLib/osrs.simba}

var
  objs: TRSObjectArray;
  atpa: T2DPointArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  objs := TRSObjectArray.Create(ObjectsJSON.GetByAction('Bank'));
  objs[1].WalkInteract(['Collect']);
end.
```

```{figure} ../../images/obj_walkselect.gif
```
*)
function TRSObject.WalkInteract(action: TStringArray; attempts: Integer = 2): Boolean;
begin
  if Self.Walker = nil then
    raise GetDebugLn('TRSObject', 'Walker pointer missing.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSObject', 'Coordinates missing.');
  if Length(Self.Coordinates) <> Length(Self.Rotations) then
    raise GetDebugLn('TRSObject', 'Coordinates and Rotations don''t match.');

  Result := Self.WalkHover(action, attempts);
  Result := Result and Self._SelectHelper(action);
end;


(*
## RSObject.DistanceTo
```pascal
function TRSObject.DistanceTo(pt: TPoint): Double;
```
Returns the distance of an object to you. Because {ref}`RSObjects` can have
multiple coordinates, only the closest one is considered for the calculation.

This is useful to for example, compared which of 2 objects are closest to you.

Example:
```pascal
me := Map.Position();

if bankBooth.DistanceTo(me) < bankChest.DistanceTo(me) then
  bankBooth.WalkClick()
else
  bankChest.WalkClick();
```
*)
function TRSObject.DistanceTo(pt: TPoint): Double;
var
  dist: Double;
  i: Integer;
begin
  Result := $FFFFFF;
  for i := 0 to High(Self.Coordinates) do
  begin
    dist := Self.Coordinates[i].DistanceTo(pt);
    if dist < Result then
      Result := dist;
  end;
end;

(*
## RSObjectArray.ClosestIndex
```pascal
function TRSObjectArray.ClosestIndex(pt: TPoint): Integer;
```
Returns the index of the `TRSObjectArray` which is closest to you.

Uses {ref}`RSObject.DistanceTo` on each of the indices of the current
`TRSObjectArray` and returns the closest index.
*)
function TRSObjectArray.ClosestIndex(pt: TPoint): Integer;
var
  closest, dist: Double;
  i, j: Integer;
begin
  closest := $FFFFFF;
  for i := 0 to High(Self) do
    for j := 0 to High(Self[i].Coordinates) do
    begin
      dist := Self[i].Coordinates[j].DistanceTo(pt);
      if dist >= closest then Continue;

      closest := dist;
      Result := i;
    end;
end;

(*
## TImage.DrawObject
```pascal
procedure TImage.DrawObject(obj: TRSObject);
```
Helper method to debug TRSObjects.
*)
procedure TImage.DrawObject(obj: TRSObject);
var
  atpa: T2DPointArray;
  boundsArray: TPolygonArray;
  i: Integer;
  coordinates: TPointArray;
begin
  if obj.FindEx(obj.Walker^.Position(), boundsArray, coordinates, atpa) then
  begin
    Self.DrawColor := TColor.Random();
    Self.DrawATPA(atpa);
  end;

  Self.DrawColor := $FFFFFF;
  if obj.Model = nil then
  begin
    for i := 0 to High(boundsArray) do
      Self.DrawTPA(boundsArray[i].Connect());
    Exit;
  end;

  for i := 0 to High(boundsArray) do
    Self.DrawTPA(TPointArray(boundsArray[i]).Edges());
end;

(*
## ShowOnTarget TRSObject
```pascal
procedure ShowOnTarget(obj: TRSObject); overload;
```
Shows an image of the target with the `TRSObject` drawn on it.
*)
procedure ShowOnTarget(obj: TRSObject); overload;
var
  img: TImage;
begin
  img := Target.GetImage();
  img.DrawObject(obj);
  img.Show();
end;

(*
## ShowOnTarget TRSObjectArray
```pascal
procedure ShowOnTarget(objs: TRSObjectArray); overload;
```
Shows an image of the target with the `TRSObjectArray` drawn on it.
*)
procedure ShowOnTarget(objs: TRSObjectArray); overload;
var
  img: TImage;
  i: Integer;
begin
  img := Target.GetImage();
  for i := 0 to High(objs) do
    img.DrawObject(objs[i]);
  img.Show();
end;

function ToString(constref obj: TRSObject): String; override;
begin
  Result := '[' + ToString(obj.UpText) + ', ' +
                  ToString(obj.Size) + ', ' +
                  ToString(obj.Coordinates) + ', ' +
                  ToString(obj.Rotations) + ', ' +
                  ToString(obj.Finder) + ', ' +
                  ToString(obj.Track) + ']';
end;
