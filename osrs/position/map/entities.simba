(*
# Entities
This file is responsible for interacting with `RSEntities`.

`RSEntities` is anything in the game that has a {ref}`ERSMinimapDot` assign to
it on the {ref}`Minimap`.

These are functionally very similar to {ref}`RSObjects` and you create and
interact with them almost the same way.

They only differ in the fact that `TRSEntity` can use a {ref}`ERSMinimapDot` to
help find them and/or {ref}`TRSDotFilters`.
Also, due to the unpredictability of entities that move, unlike {ref}`RSObjects`
these do not have a rotation field.
*)

{$DEFINE WL_RSENTITIES_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
  ENPCData = enum(ID, NAME, LEVEL, CATEGORY, MINIMAPDOT, ACTIONS, SIZE, COORDINATES, COLORS);

(*
## TRSEntity
Main type to handle {ref}`RSEntity`.
*)
  TRSEntity = record
    UpText: TStringArray;
    Size: TVector3;
    Model: TModel;
    Coordinates: TPointArray;
    Filter: TRSDotFilterArray;
    Finder: TColorFinder;
    Track: Boolean;
    MinimapDots: ERSMinimapDots;
    LastCoordinate: TPoint;
    Walker: PRSWalker;
  end;

(*
## TRSEntityArray
Array of {ref}`TRSEntity`.
*)
  TRSEntityArray = array of TRSEntity;

(*
## RSEntity.Create
```pascal
function TRSEntity.Create(walker: PRSWalker; size: TVector3; coordinates: TPointArray; uptext: TStringArray = []; dots: ERSMinimapDots = []): TRSEntity; static;
function TRSEntity.Create(json: TJSONObject): TRSEntity; static; overload;
```
Createors to create your {ref}`TRSEntity`.

Assuming you create the `RSEntity` manually, the Createor will provide you
with a fully built `TRSEntity` without a finder.

You may optionally assign one later if you want:
```pascal
{$I WaspLib/osrs.simba}
var
  npc: TRSEntity;
begin
  Map.Setup([ERSChunk.VARROCK]);             //varrock west southern most banker
  npc := TRSEntity.Create(@Map.Walker, [1,1,7], [[8652,36686]], ['Banker'], [ERSMinimapDot.NPC]);
  //npc.Finder.Colors += [$543B3B, 10.121, EColorSpace.HSV, [0.528, 1.275, 1.199]];
end;
```

The `json` version of the function expects a specific json structure which is
the one that {ref}`Map JSONs` provide:
```pascal
{$I WaspLib/osrs.simba}
var
  npc: TRSEntity;
begin
  Map.Setup([ERSChunk.VARROCK]);
  //Item[0] because this returns a JSON array. For more info read Map JSONs documentation.
  npc := TRSEntity.Create(NPCsJSON.GetByName('banker', 1).Item[0]);
end;
```
*)
function TRSEntity.Create(walker: PRSWalker; size: TVector3; radius: Integer; coordinates: TPointArray; uptext: TStringArray = []; dots: ERSMinimapDots = []): TRSEntity; static;
var
  pt: TPoint;
begin
  Result.Coordinates := coordinates;
  Result.Size := size;

  if dots <> [] then
    Result.MinimapDots := dots;
  if uptext <> [] then
    Result.UpText := uptext;

  Result.Finder := Default(TColorFinder);
  Result.Walker := walker;

  for pt in coordinates do
    Result.Filter += TRSDotFilter.Create([], TCircle.Create(pt.X, pt.Y, radius), True);
end;

function TRSEntity.Create(json: TJSONObject): TRSEntity; static; overload;
var
  i, j, l: Integer;
  unique: array of TColorArray;
  color: TColor;
  best: TBestColor;
  coord: TJSONArray;
begin
  if json.Typ <> EJSONType.OBJ then
    raise GetDebugLn('TRSEntity', 'JSON Object expected, got ' + ToStr(json.Typ) + '.');

  with json.Item[Ord(ENPCData.NAME)] do
    if AsString <> 'null' then
      Result.UpText := [AsString];

  if json.Item[Ord(ENPCData.MINIMAPDOT)].AsBool then
    Result.MinimapDots := [ERSMinimapDot.NPC];

  with json.Item[Ord(ENPCData.SIZE)] do
  begin
    Result.Size.X := Item[0].AsInt * 0.8;
    Result.Size.Y := Item[1].AsInt * 0.8;
    Result.Size.Z := Item[2].AsInt / 40;
  end;

  if Abs(Result.Size.Z) < 0.05 then
    Result.Size.Z := 3.0;

  with json.Item[Ord(ENPCData.COORDINATES)] do
    for i := 0 to Count-1 do
    begin
      coord := Item[i];
      Result.Coordinates += [coord.Item[0].AsInt, coord.Item[1].AsInt];
      Result.Filter += TRSDotFilter.Create([], TCircle.Create(coord.Item[0].AsInt, coord.Item[1].AsInt, 40), True);
    end;

  with json.Item[Ord(ENPCData.COLORS)] do
    for i := 0 to Count-1 do
    begin
      color := Item[i].AsInt;

      for j := 0 to High(unique) do
      begin
        for l := 0 to High(unique[j]) do
          if ColorDistance(color, unique[j, l], EColorSpace.HSL, [1.5, 1.5, 1.5]) < 15 then
          begin
            unique[j] += color;
            Continue(3);
          end;
      end;

      unique += [color];
    end;

  for i := 0 to High(unique) do
  begin
    best := GetBestColor(EColorSpace.HSL, unique[i]);
    WriteLn best;
    Result.Finder.Colors += [best.Color, best.Tolerance*1.5, EColorSpace.HSL, [best.Mods[0]*1.5, best.Mods[1]*1.5, best.Mods[2]*1.5]];
  end;

  Result.Walker := @Map.Walker;
end;

(*
## RSEntityArray.Create
```pascal
function TRSEntityArray.Create(json: TJSONArray): TRSEntityArray; static;
```
Create function to build your {ref}`TRSObjectArray`.

This only accepts a `json` array and it expects a specific json structure which is
the one that {ref}`Map JSONs` provide.

Example:
```pascal
{$I WaspLib/osrs.simba}

var
  entities: TRSEntityArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  entities := TRSEntityArray.Create(NPCsJSON.GetByName('Banker')); 
end;
```
*)
function TRSEntityArray.Create(json: TJSONArray): TRSEntityArray; static;
var
  i: Integer;
begin
  if json.Typ <> EJSONType.ARR then
    raise GetDebugLn('TRSEntity', 'JSON Array expected, got ' + ToStr(json.Typ) + '.');

  SetLength(Result, json.Count);
  for i := 0 to High(Result) do
    Result[i] := TRSEntity.Create(json.Item[i]);
end;


(*
## Entity._GetBounds
```pascal
function TRSEntity._GetBounds(me: TPoint; vector: TVector2; size: TVector3; height, radians: Single): TCuboid;
```
Internal helper function for {ref}`TRSEntity.GetBoundsArray`.
*)
function TRSEntity._GetBounds(me: TPoint; vector: TVector2; size: TVector3; height, radians: Single): TPolygon;
var
  corners: TVector3Array;
  pt: TPoint;
begin
  pt := me + vector.ToPoint() - Minimap.Center;
  if Self.Model <> nil then
    Exit(Self.Model.GetArea(Self.Model.Project(vector.ToVec3(Self.Walker^.Height(pt, False) - height), 0, radians)));


  size.X := size.X*2;
  size.Y := size.Y*2;

  corners := [
    [vector.X-size.X, vector.Y-size.Y, Self.Walker^.Height(pt - [1,3],  False) - height],
    [vector.X+size.X, vector.Y-size.Y, Self.Walker^.Height(pt + [3,-3], False) - height],
    [vector.X+size.X, vector.Y+size.Y, Self.Walker^.Height(pt + [3,1],  False) - height],
    [vector.X-size.X, vector.Y+size.Y, Self.Walker^.Height(pt - [1,1],  False) - height],
    [vector.X-size.X, vector.Y-size.Y, Self.Walker^.Height(pt - [1,3],  False) - height+size.Z],
    [vector.X+size.X, vector.Y-size.Y, Self.Walker^.Height(pt + [3,-3], False) - height+size.Z],
    [vector.X+size.X, vector.Y+size.Y, Self.Walker^.Height(pt + [3,1],  False) - height+size.Z],
    [vector.X-size.X, vector.Y+size.Y, Self.Walker^.Height(pt - [1,1],  False) - height+size.Z]
  ];

  Result := Projection.Run(corners, radians).ConvexHull();
end;

(*
## Entity.GetBoundsArray
```pascal
function TRSEntity.GetBoundsArray(me: TPoint; angle: Single = $FFFF): TCuboidArray;
```
Internal function that returns an array of cuboids of the entity if it's visible
on the {ref}`MainScreen`.
*)
function TRSEntity.GetBoundsArray(me: TPoint; out coordinates: TPointArray; radians: Single = $FFFF): TPolygonArray;
var
  weights: TDoubleArray;
  meLocal, pt: TPoint;
  i: Integer;
  h, dist: Double;
  vector: TVector2;
  dots: TPointArray;
begin
  if radians = $FFFF then
    radians := Minimap.CompassRadians;

  meLocal := Self.Walker^.GetLocal(me);

  h := Self.Walker^.Height(meLocal - [1,3], False) + Self.Walker^.Height(meLocal + [3,-3], False) +
       Self.Walker^.Height(meLocal + [3,1], False) + Self.Walker^.Height(meLocal - [1,1], False);
  h := h/4;

  if Self.Filter <> [] then
  begin
    dots := Minimap.GetFilteredDotArray(Self.MinimapDots, Self.Walker^.FiltersToMM(me, Self.Filter, radians));
    if dots = [] then
      Exit;

    dots := dots.SortFrom(Minimap.Center);
    for i := 0 to High(dots) do
    begin
      pt := Self.Walker^.MM2Map(me, dots[i], radians);
      coordinates += pt;

      vector := Self.Walker^.Point2MMVec(me, pt, radians);
      vector := vector.Rotate(-radians, Minimap.Center);
      Result += Self._GetBounds(meLocal, vector, Self.Size, h, radians);
    end;
    Exit;
  end;

  for i := 0 to High(Self.Coordinates) do
  begin
    pt := Self.Coordinates[i];
    dist := me.DistanceTo(pt);
    if dist > 85 then
      Continue;

    weights += dist;
    coordinates += pt;

    vector := Self.Walker^.Point2MMVec(me, pt, radians);
    vector := vector.Rotate(-radians, Minimap.Center);
    Result += Self._GetBounds(meLocal, vector, Self.Size, h, radians);
  end;

  if Result <> [] then
  begin
    Sort(Result, weights, True);
    coordinates.Sort(weights, True);
  end;
end;

(*
## TRSEntity.Find
```pascal
function TRSEntity.Find(cuboidArray: TCuboidArray): T2DPointArray;
```
Internal TRSEntity method responsible for filtering a TCuboidArray by what's visible in the mainscren.
This is meant to filter TRSEntity.GetBoundsArray() so targets that are outside of the mainscreen are filtered out.
You will probably never need to use this directly.
*)
function TRSEntity.FindOnMainScreen(out coordinates: TPointArray; boundsArray: TPolygonArray): T2DPointArray;
var
  i: Integer;
  found: TBooleanArray;
begin
  if Self.Finder <> Default(TColorFinder) then
  begin
    Self.Finder.FindEx(Result, found, boundsArray, Self.Model = nil);

    for i := High(found) downto 0 do
      if not found[i] then
        Delete(coordinates, i, 1);

    Exit;
  end;

  if Self.Model <> nil then
    Exit(boundsArray);

  for i := 0 to High(boundsArray) do
    Result += TPointArray(boundsArray[i]).Connect().ShapeFill();
end;

(*
## TRSEntity.FindEx
```pascal
function TRSEntity.FindEx(me: TPoint; out boundsArray: TPolygonArray; out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
```
Internal {ref}`TRSEntity` method used to find a {ref}`RSEntity`.

You also have {ref}`RSEntity.Find` to find entities, this version of the method
is internal because it returns extra information about the found entities for
internal use, like it's `cuboids` for example.

This also returns an `atpa` containing the colors of the object that were found
assuming the object has a {ref}`TColorFinder` setup.
If not, the cuboids area are returned as the match.
*)
function TRSEntity.FindEx(me: TPoint; out boundsArray: TPolygonArray; out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
begin
  boundsArray := Self.GetBoundsArray(me, coordinates);
  if boundsArray = [] then Exit;
  atpa := Self.FindOnMainScreen(coordinates, boundsArray);

  Result := atpa <> [];
end;


(*
## RSEntity.Find
```pascal
function TRSEntity.Find(out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
function TRSEntity.Find(out atpa: T2DPointArray): Boolean; overload;
```
{ref}`TRSEntity` method used to find a {ref}`RSEntity`.
This returns True/False if the entity was found and it's `atpa` which cointains
the colors of it that were found.

For more information on this refer to {ref}`TRSEntity.FindEx`, it's an internal
function but is used within this one and will go into more detail.
*)
function TRSEntity.Find(out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
var
  boundsArray: TPolygonArray;
begin
  Result := Self.FindEx(Self.Walker^.Position(), boundsArray, coordinates, atpa);
end;

function TRSEntity.Find(out atpa: T2DPointArray): Boolean; overload;
var
  coordinates: TPointArray;
  boundsArray: TPolygonArray;
begin
  Result := Self.FindEx(Self.Walker^.Position(), boundsArray, coordinates, atpa);
end;


function TRSEntity.FindFrom(position: TPoint; out atpa: T2DPointArray): Boolean;
var
  boundsArray: TPolygonArray;
  coordinates: TPointArray;
begin
  Result := Self.FindEx(position, boundsArray, coordinates, atpa);
end;

(*
## TRSEntity._UpTextCheck
```pascal
function TRSEntity._UpTextCheck(out shouldExit: Boolean): Boolean;
```
Internal TRSEntity helper method that is used by all hovering methods.
You probably don't need to use this directly.
*)
function TRSEntity._UpTextCheck(out shouldExit: Boolean): Boolean;
var
  text: String;
begin
  shouldExit := True;

  if (RSClient.Mode = ERSMode.FIXED) and MSInterface.IsOpen() then
    Exit;

  if Self.UpText <> [] then
    Self.Walker^.TargetUpText := Copy(Self.UpText);

  text := MainScreen.UpText;

  if text.Contains('>') and not Self.Walker^.ActionUpText.Contains(['>']) then
  begin
    ChooseOption.Close();
    Exit;
  end;

  if (Self.UpText <> []) and text.ContainsAny(Self.UpText) then
    Exit(True);

  shouldExit := False;
end;

(*
## TRSEntity._HoverHelper
```pascal
function TRSEntity._HoverHelper(attempts: Integer; trackTarget: Boolean): Boolean;
```
Internal helper method used to hover a TRSEntity target.
You should not use this directly.
*)
function TRSEntity._HoverHelper(attempts: Integer): Boolean;
var
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  coordinates, tpa: TPointArray;
begin
  Result := Self._UpTextCheck(shouldExit);
  if shouldExit then Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if Length(coordinates) <> Length(atpa) then
        raise 'SOMETHING WENT WRONG CACHING COORDINATES.';

      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then Exit(True);

    if attempt <> (attempts - 1) then
      Continue;

    Minimap.CompassRadians := Minimap.CompassRadians + PI/3.6 * Random(-1,1);
  end;
end;

(*
## TRSEntity._WalkHoverHelper
```pascal
function TRSEntity._WalkHoverHelper(attempts: Integer; trackTarget: Boolean): Boolean;
```
Internal helper method used to walk and hover a TRSEntity target.
You should not use this directly.

This is responsible for deciding wether we should walk to a TRSEntity target or not before attempting to hover it.
*)
function TRSEntity._WalkHoverHelper(attempts: Integer): Boolean;
var
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  coordinates, tpa: TPointArray;
  path: TGraphNodeArray;
  me, closest: TPoint;
begin
  Result := Self._UpTextCheck(shouldExit) or Self.Walker^.RedClicked;
  if shouldExit then Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if Length(coordinates) <> Length(atpa) then
        raise 'SOMETHING WENT WRONG CACHING COORDINATES.';

      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then Exit(True);

    me := Self.Walker^.Position();
    closest := Self.Walker^.GetClosestPoint(me, Self.Coordinates, path);

    if path = [] then
    begin
      path := Self.Walker^.WebGraph^.PathToNear(me, closest, 0.33);
      if path = [] then
        raise GetDebugLn('TRSEntity', 'Can''t path to object.');
    end;

    if me.DistanceTo(closest) > 50 then
    begin
      Self.Walker^.WebWalkEx(me, closest, 30, 0.15);
      Continue;
    end;

    if attempt <> (attempts - 1) then Continue;

    if me.DistanceTo(closest) > 25 then
    begin
      Self.Walker^.WebWalkEx(me, closest, 25, 0.15);
      Continue;
    end;

    Minimap.CompassRadians := Minimap.CompassRadians + PI/3.6 * Random(-1,1);
  end;
end;

(*
## TRSEntity._PreHoverHelper
```pascal
function TRSEntity.PreHoverHelper(attempts: Integer): Boolean;
```
Internal helper method used to pre-hover a TRSEntity target.
You should not use this directly.
*)
function TRSEntity._PreHoverHelper(me: TPoint; attempts: Integer = 2): Boolean;
var
  attempt: Integer;
  atpa: T2DPointArray;
begin
  for attempt := 0 to attempts do
  begin
    if not Self.FindFrom(me, atpa) then Continue;
    Mouse.Move(atpa.Random().Random());
    Exit(True);
  end;
end;


(*
## TRSEntity._ClickHelper
```pascal
function TRSEntity._ClickHelper(leftClick: Boolean): Boolean;
```
Internal TRSEntity helper method that is used by other clicking methods.
You probably don't need to use this directly.

This is what's responsible for deciding if we click a target we are hovering or not.
*)
function TRSEntity._ClickHelper(leftClick: Boolean): Boolean;
begin
  Self.Walker^.TargetUpText := [];
  Self.Walker^.ActionUpText := [];

  if Self.Walker^.RedClicked then
  begin
    Self.Walker^.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Select(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
    Exit;
  end;

  if leftClick and Biometrics.RedClick(EMouseButton.LEFT, 2) then
    Exit(True);

  Result := not leftClick and (Self.UpText <> []) and ChooseOption.Select(Self.UpText);
end;

(*
## TRSEntity._SelectHelper
```pascal
function TRSEntity._SelectHelper(action: TStringArray): Boolean;
```
Internal TRSEntity helper method that is used by other select methods.
You probably don't need to use this directly.

This is what is responsible for deciding if we just left click a target we are hovering or right click it and choose an option.
*)
function TRSEntity._SelectHelper(action: TStringArray): Boolean;
begin
  Self.Walker^.TargetUpText := [];
  Self.Walker^.ActionUpText := [];

  if Self.Walker^.RedClicked then
  begin
    Self.Walker^.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() and ChooseOption.Select(action) then
    Exit(True);

  if MainScreen.IsUpText(action) then
    Exit(Biometrics.RedClick(EMouseButton.LEFT, 2));

  Result := ChooseOption.Select(action);
end;


(*
## TRSEntity.Hover
```pascal
function TRSEntity.Hover(attempts: Integer = 2; trackTarget: Boolean = TRSEntity.TrackTarget): Boolean;
```
Method used to hover a TRSEntity target if it's found on the mainscreen.
It can update the target position while the mouse moves with **trackTarget**.

Example:
```pascal
RSW.WebWalk(WaspWeb.LOCATION_VARROCK);
RSObjects.GEBank.Hover(); //Be in GE with a walker setup there.
```
*)
function TRSEntity.Hover(attempts: Integer = 2): Boolean;
begin
  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Find(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
  end;

  if Self.Walker = nil then
    raise GetDebugLn('TRSEntity', 'Missing the walker pointer.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSEntity', 'FindFrom requires the object to have coordinates.');

  //TODO:
  //if not Self.Walker^.MakePointVisible(Self.Coordinates) then Exit;

  Result := Self._HoverHelper(attempts);
end;

(*
## TRSEntity.WalkHover
```pascal
function TRSEntity.WalkHover(attempts: Integer = 2; trackTarget: Boolean = TRSEntity.TrackTarget): Boolean;
```
Method used to walk and hover a TRSEntity target if it's found on the mainscreen after walking.
It can update the target position while the mouse moves with **trackTarget**.

Example:
```pascal
//Be in varrock with a varrock map loaded.
RSW.WebWalk(WaspWeb.LOCATION_VARROCK);
RSObjects.GEBank.WalkHover();
```
*)
function TRSEntity.WalkHover(attempts: Integer = 2): Boolean;
var
  me, closest: TPoint;
  path: TGraphNodeArray;
  hasPath: Boolean;
begin
  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Find(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
  end;

  if Self.UpText <> [] then
    Self.Walker^.TargetUpText := Copy(Self.UpText);

  me :=  Self.Walker^.Position();
  closest := Self.Walker^.GetClosestPoint(me, Self.Coordinates, path);

  //if the point is not reachable with the webgraph (like a banker behind a booth) then pick nearest node as target
  if path = [] then
  begin
    path := Self.Walker^.WebGraph^.PathToNear(me, closest, 0.33);
    if path = [] then
      raise GetDebugLn('TRSEntity', 'Can''t path to object.');
    hasPath := True;
  end;

  // check if doors need to be passed to reach target
  if hasPath or Self.Walker^.WebGraph^.WalkableClusters.InSameTPA(me, closest) then
  begin
    if not Self.Walker^.MakePointVisible(closest) and not Self.Walker^.WebWalkEx(me, closest, 30, 0.15) then
      Exit;
  end
  else
  if not Self.Walker^.WebWalk(closest, 30, 0.15) then
    Exit;

  Result := Self._WalkHoverHelper(attempts);
end;


(*
## TRSEntity.Click
```pascal
function TRSEntity.Click(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
```
Method used to click a TRSEntity target if it's found on the mainscreen.

Example:
```pascal
//Be in ge with a ge map loaded.
WriteLn RSObjects.GEBank.Click();
```
*)
function TRSEntity.Click(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
begin
  Result := Self.Hover(attempts) and Self._ClickHelper(leftClick);
end;

(*
## TRSEntity.Interact
```pascal
function TRSEntity.Interact(action: TStringArray; attempts: Integer = 2): Boolean;
```
Method used to select an option on a TRSEntity target if it's found on the mainscreen.
*)
function TRSEntity.Interact(action: TStringArray; attempts: Integer = 2): Boolean;
begin
  Self.Walker^.ActionUpText := action;
  Result := Self.Hover(attempts) and Self._SelectHelper(action);
  Self.Walker^.ActionUpText := [];
end;

(*
## TRSEntity.WalkClick
```pascal
function TRSEntity.WalkClick(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
```
Method used to walk and click a TRSEntity target if it's found on the mainscreen.

Example:
```pascal
//Be in ge with a ge map loaded, preferably far away so it has to walk.
WriteLn RSObjects.GEBank.WalkClick();
```
*)
function TRSEntity.WalkClick(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
begin
  if Self.Walker = nil then
    raise GetDebugLn('TRSEntity', 'Missing the walker pointer.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSEntity', 'FindFrom requires the object to have coordinates.');

  Result := Self.WalkHover(attempts) and Self._ClickHelper(leftClick);
  Self.Walker^.TargetUpText := [];
end;

(*
## TRSEntity.WalkInteract
```pascal
function TRSEntity.WalkInteract(action: TStringArray; attempts: Integer = 2): Boolean;
```
Method used to walk and select an option on a TRSEntity target if it's found on the mainscreen.
*)
function TRSEntity.WalkInteract(action: TStringArray; attempts: Integer = 2): Boolean;
begin
  if Self.Walker = nil then
    raise GetDebugLn('TRSEntity', 'Missing the walker pointer.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSEntity', 'FindFrom requires the object to have coordinates.');

  Self.Walker^.ActionUpText := action;

  Result := Self.WalkHover(attempts) and Self._SelectHelper(action);

  Self.Walker^.TargetUpText := [];
  Self.Walker^.ActionUpText := [];
end;


function TRSEntity.DistanceTo(pt: TPoint): Double;
var
  dist: Double;
  i: Integer;
begin
  Result := $FFFFFF;
  for i := 0 to High(Self.Coordinates) do
  begin
    dist := Self.Coordinates[i].DistanceTo(pt);
    if dist < Result then
      Result := dist;
  end;
end;

function TRSEntityArray.ClosestIndex(pt: TPoint): Integer;
var
  closest, dist: Double;
  i, j: Integer;
begin
  closest := $FFFFFF;
  for i := 0 to High(Self) do
    for j := 0 to High(Self[i].Coordinates) do
    begin
      dist := Self[i].Coordinates[j].DistanceTo(pt);
      if dist >= closest then Continue;

      closest := dist;
      Result := i;
    end;
end;

(*
## TImage.DrawEntity
```pascal
procedure TImage.DrawEntity(npc: TRSEntity);
```
Helper method to debug TRSEntity.
*)
procedure TImage.DrawEntity(entity: TRSEntity);
var
  me: TPoint;
  atpa: T2DPointArray;
  boundsArray: TPolygonArray;
  i: Integer;
  filters: TRSDotFilterArray;
  filter: TRSDotFilter;
  coordinates: TPointArray;
begin
  me := entity.Walker^.Position();
  filters := entity.Walker^.FiltersToMM(me, entity.Filter, Minimap.CompassRadians);

  for filter in filters do
  begin
    if not Minimap.Bounds.Overlap(filter.Poly.Bounds()) and
       not Minimap.Bounds.Overlap(filter.Circle.Bounds) then Continue;

    if filter.Inside then
      Self.DrawColor := $00FF00
    else
      Self.DrawColor := $0000FF;

    Self.DrawPolygon(filter.Poly);
    Self.DrawCircle(filter.Circle);
  end;

  if entity.FindEx(me, boundsArray, coordinates, atpa) then
  begin
    Self.DrawColor := TColor.Random();
    Self.DrawATPA(atpa);
  end;

  Self.DrawColor := $FFFFF;
  for i := 0 to High(boundsArray) do
    Self.DrawTPA(boundsArray[i].Connect());
end;

(*
## ShowOnTarget TRSEntity
```pascal
procedure ShowOnTarget(entity: TRSEntity); overload;
```
Shows an image of the target with the `TRSEntity` drawn on it.
*)
procedure ShowOnTarget(entity: TRSEntity); overload;
var
  img: TImage;
begin
  img := Target.GetImage();
  img.DrawEntity(entity);
  img.Show();
end;

(*
## ShowOnTarget TRSEntityArray
```pascal
procedure ShowOnTarget(entities: TRSEntityArray); overload;
```
Shows an image of the target with the `TRSEntityArray` drawn on it.
*)

procedure ShowOnTarget(entities: TRSEntityArray); overload;
var
  img: TImage;
  i: Integer;
begin
  img := Target.GetImage();
  for i := 0 to High(entities) do
    img.DrawEntity(entities[i]);
  img.Show();
end;


function ToString(constref entity: TRSEntity): String; override;
begin
  Result := '[' + ToString(entity.UpText) + ', ' +
                  ToString(entity.Size) + ', ' +
                  ToString(entity.Coordinates) + ', ' +
                  ToString(entity.Finder) + ', ' +
                  ToString(entity.MinimapDots) + ', ' +
                  ToString(entity.Track) + ']';
end;
