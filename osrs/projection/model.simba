{$DEFINE WL_MODEL_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
  TModelFace = object
    Vertices: array [0..2] of Int32;
    Material: Int32;
  end;

  TModel = object
    Vertices: TVector3Array;
    Faces: array of TModelFace;
    Materials: TColorArray;
    Alphas: TByteArray;
    Width, Depth, Height: Single;
  end;

procedure TModel.LoadMTL(fileName: string);
var
  strings: TLazStringList;
  line: string;
  parts: TStringArray;
  color: TColorRGB;
  i: Integer;
begin
  strings := TLazStringList.Create();

  try
    strings.LoadFromFile(fileName);
    for i := 0 to strings.Count - 1 do
    begin
      line := strings.Strings[i].Trim();
      if (line = '') or (line[1] = '#') then Continue;

      if line.StartsWith('Kd ', False) then
      begin
        parts := line.Split(' ', True);
        if Length(parts) >= 4 then
        begin
          color.R := Round(StrToFloat(parts[1]) * 255);
          color.G := Round(StrToFloat(parts[2]) * 255);
          color.B := Round(StrToFloat(parts[3]) * 255);

          Self.Materials += color.ToColor();
          Self.Alphas += $FF;
        end;
      end;

      if line.StartsWith('d ', False) then
      begin
        parts := line.Split(' ', True);
        if Length(parts) = 2 then
          Self.Alphas[High(Self.Alphas)] := Round(StrToFloat(parts[1], 1.0) * 255);
      end;
    end;
  finally
    strings.Free();
  end;
end;

procedure TModel.LoadOBJ(fileName: String);
var
  strings: TLazStringList;
  parts: TStringArray;
  line: String;
  vertex: TVector3;
  face: TModelFace;
  i, j: Integer;
  idx: Integer = -1;
  x1, y1, x2, y2, z1, z2: Single;
begin
  strings := TLazStringList.Create();
  try
    strings.LoadFromFile(fileName);

    x1 := $FFFFFF;
    y1 := $FFFFFF;
    z1 := $FFFFFF;

    for i := 0 to strings.Count-1 do
    begin
      line := strings.Strings[i].Trim();
      if (line = '') or (line[1] = '#') then Continue;

      if line.StartsWith('usemtl ', False) then  //which material to use line
      begin
        idx := line.ExtractInteger(-1);
        Continue;
      end;

      if line.StartsWith('v ', False) then //vertices line
      begin
        parts := line.Split(' ', False);
        if Length(parts) >= 4 then
        begin
          vertex.X := StrToFloat(parts[1])*4/128;
          vertex.Y := StrToFloat(parts[3])*4/128;
          vertex.Z := StrToFloat(parts[2])*4/128;
          Self.Vertices += vertex;

          x1 := Min(vertex.X, x1); x2 := Max(vertex.X, x2);
          y1 := Min(vertex.Y, y1); y2 := Max(vertex.Y, y2);
          z1 := Min(vertex.Z, z1); z2 := Max(vertex.Z, z2);
        end;
        Continue;
      end;

      if line.StartsWith('f ', False) then //face line
      begin
        parts := line.Split(' ', True);
        if Length(parts) >= 4 then
        begin
          face := new TModelFace();
          for j := 0 to 2 do
            face.Vertices[j] := StrToInt64(parts[j+1].Split('/')[0], 0) - 1;

          if InRange(idx, 0, High(Self.Materials)) then
            face.Material := idx;
          Self.Faces += face;
        end;
      end;
    end;
  finally
    strings.Free();
  end;

  Self.Width := x2-x1;
  Self.Depth := y2-y1;
  Self.Height := z2-z1;
end;


function TModel.Construct(objFile: String; mtlFile: String = ''): TModel; static;
begin
  if mtlFile <> '' then
    Result.LoadMTL(mtlFile);
  Result.LoadOBJ(objFile);
end;


function TModel.ProjectEx(minimapCoord: TVector3; heights: array [0..3] of Single; rotation, radians: Single): TPointArray;
var
  i: Integer;
  vertices: TVector3Array;
  width, depth: Single;
begin
  width := Self.Width/2;
  depth := Self.Depth/2;

  for i := 0 to High(Self.Vertices) do
  begin
    vertices += Self.Vertices[i].Rotate(rotation, minimapCoord.X, minimapCoord.Y);

    if vertices[i].X < width then
    begin
      if vertices[i].Y < depth then vertices[i].Z += heights[0]
      else if vertices[i].Y > depth then vertices[i].Z += heights[2]
      else vertices[i].Z += (heights[0] + heights[2]) / 2;
    end
    else if vertices[i].X > width then
    begin
      if vertices[i].Y < depth then vertices[i].Z += heights[1]
      else if vertices[i].Y > depth then vertices[i].Z += heights[3]
      else vertices[i].Z += (heights[1] + heights[3]) / 2;
    end
    else
    begin
      if vertices[i].Y < depth then vertices[i].Z += (heights[0]+heights[1]) / 2
      else if vertices[i].Y > depth then vertices[i].Z += (heights[2]+heights[3]) / 2
      else vertices[i].Z += (heights[0] + heights[1] + heights[2] + heights[3]) / 4;
    end;

    vertices[i].X += minimapCoord.X;
    vertices[i].Y += minimapCoord.Y;
    vertices[i].Z += minimapCoord.Z;
  end;

  Result := Projection.Run(vertices, radians);
end;

function TModel.Project(minimapCoord: TVector3; rotation, radians: Single): TPointArray;
begin
  with minimapCoord do
    Result := Projection.Run(Self.Vertices.Offset([X,Y,Z]).Rotate(rotation,X,Y), radians);
end;

function TModel.GetArea(projection: TPointArray): TPointArray;
var
  i, j: Integer;
  polygon: TPolygon;
begin
  for i := High(Self.Faces) downto 0 do
  begin
    for j := 0 to 2 do
      polygon += projection[Self.Faces[i].Vertices[j]];
    Result += polygon.Connect().ShapeFill();
    polygon := [];
  end;
end;

function TModel.GetEdges(projection: TPointArray): TPointArray;
begin
  Result := Self.GetArea(projection).Edges();
end;

procedure TModel.DrawModel(img: TImage; projection: TPointArray; outline: Boolean = True);
var
  i, j: Integer;
  polygon: TPolygon;
  triangle, triangles, edge: TPointArray;
begin
  if Self.Materials <> [] then
  begin
    for i := High(Self.Faces) downto 0 do
    begin
      for j := 0 to High(Self.Faces[i].Vertices) do
        polygon += projection[Self.Faces[i].Vertices[j]];
      img.DrawAlpha := Self.Alphas[Self.Faces[i].Material];
      img.DrawColor := Self.Materials[Self.Faces[i].Material];
      img.DrawPolygonFilled(polygon);
      edge += polygon.Connect().ShapeFill();
      polygon := [];
    end;
    if outline then
    begin
      img.DrawColor := $FFFFFF;
      img.DrawTPA(edge.Edges());
    end;
    Exit;
  end;

  for i := High(Self.Faces) downto 0 do
    begin
      for j := 0 to High(Self.Faces[i].Vertices) do
        polygon += projection[Self.Faces[i].Vertices[j]];
      triangle := polygon.Connect();
      triangles += triangle;
      edge += triangle.ShapeFill();
      polygon := [];
    end;


    img.DrawColor := $00FFFF;
    img.DrawTPA(triangles);
    if outline then
    begin
      img.DrawColor := $FFFFFF;
      img.DrawTPA(edge.Edges());
    end;
end;
