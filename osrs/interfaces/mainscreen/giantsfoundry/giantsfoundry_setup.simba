(*
# Giants' Foundry Mould Setup Interface
Interface for handling the Giants' Foundry mould selection and setup.
This interface allows automatic selection of optimal moulds based on
Kovac's commission requirements.
```{figure} ../../images/giantsfoundrysetup_interface.png
```
*)

{$DEFINE WL_GIANTFOUNDRY_SETUP_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
(*
## ERSGiantsFoundryMouldType
```pascal
ERSGiantsFoundryMouldType = (FORTE, BLADE, TIP);
```
Enum representing the possible mould types
*)
  ERSGiantsFoundryMouldType = enum(FORTE, BLADE, TIP);

(*
## TRSFoundryMould
Record representing a single mould piece with its attributes and scores.
*)
  TRSGiantsFoundryMould = record
    Name: String;
    MouldType: ERSGiantsFoundryMouldType;
    Heavy: Int32;
    Light: Int32;
    Broad: Int32;
    Narrow: Int32;
    Flat: Int32;
    Spiked: Int32;
    LevelRequired: Int32;
    IsDefault: Boolean;
  end;


  TRSGiantFoundrySetupAttribute = record
    Bounds: TBox;
    Attribute: ERSGiantsFoundryAttribute;
    AttributeTotalScore: Integer;
  end;

(*
## TRSGiantsFoundryMouldSelection
Record representing a complete mould setup (Forte, Blade, Tip).
*)
  TRSGiantsFoundryMouldSelection = record
    Forte: TRSGiantsFoundryMould;
    Blade: TRSGiantsFoundryMould;
    Tip: TRSGiantsFoundryMould;
    TotalScore: TRSGiantFoundrySetupAttribute;
  end;

(*
## TRSGiantsFoundrySetup
Record responsible to handle the {ref}`GiantsFoundrySetup` interface.
This relates to the
*)

  TRSGiantsFoundrySetup = record
    Title: TRSInterfaceTitle;
    Scroll: TRSScrollBar;

    Bounds, MouldsArea, CommissionArea: TBox;
    MouldSlots: TBoxArray;
    SetMouldButton, ResetMouldButton: TRSButton;
    MouldTypeButtons: array [ERSGiantsFoundryMouldType] of TRSButton;
    AvailableMoulds: array of TRSGiantsFoundryMould;

    Atrribute1, Atrribute2: TRSGiantFoundrySetupAttribute;
  end;

(*
## GiantsFoundrySetup.FindItemBoundaries
```pascal
function TRSGiantsFoundrySetup.FindMouldBoundaries(): TBoxArray;
```
Finds mould boundaries and returns them as a TBoxArray.

You have 2 ways of getting the mould slots, a static one:
```pascal
ShowOnTarget(GiantsFoundrySetup.MouldSlots);
```


And a dynamic one:
```pascal
ShowOnTarget(GiantsFoundrySetup.FindMouldBoundaries());
```

There are use cases for both, internally, `GiantsFoundrySetup.FindItemBoundaries` is usually used.

*)
function TRSGiantsFoundrySetup.FindMouldBoundaries(): TBoxArray;
var
  tpa, final: TPointArray;
  atpa: T2DPointArray;
  b: TBox;
begin
  // All white[$CBCFD1, 0.000, EColorSpace.RGB, [1.000, 1.000, 1.000]]
  // the brick[$9BA8AD, 0.000, EColorSpace.RGB, [1.000, 1.000, 1.000]]
  // [$96A4A5, 18.051, EColorSpace.RGB, [1.055, 1.080, 0.866]]
  final := Target.FindColor($96A4A5, 24, Self.MouldsArea);
  if final = [] then Exit;

  atpa := final.Cluster(200, 5);
  for tpa in atpa do
  begin
    b := tpa.Bounds();
    if b.Height <= 28 then Continue;
    Writeln(Self.MouldsArea);
    Result += TBoxArray.Create([Self.MouldsArea.X1 + 2, b.Y1-5], 1, 1, Self.MouldsArea.X2 - Self.MouldsArea.X1 - 9, Min(Self.MouldsArea.Y2-b.Y1, 39), [0, 17]);

  end;
end;

(*
## GiantsFoundrySetup.SetupInterface
```pascal
procedure TRSGiantsFoundrySetup.SetupInterface();
```
Internal method used to setup the {ref}`TRSGiantsFoundrySetup` coordinates.
This is automatically called for you on the {ref}`GiantsFoundry` variable.
*)
procedure TRSGiantsFoundrySetup.SetupInterface();
var
  boxes: TBoxArray;
  mouldtype: ERSGiantsFoundryMouldType;
begin
  case RSClient.Mode of
    ERSMode.FIXED:
      Self.Bounds := MSInterface.CreateBounds([0, 0, 0, 0], 480, 314);
    ERSMode.RESIZABLE, ERSMode.MODERN_COMPACT, ERSMode.MODERN_WIDE:
      begin
      if (MSInterface.Bounds.X2 < 640) or (MSInterface.Bounds.Y2 < 481) then
        Self.Bounds := MSInterface.CreateBounds([0, -1, 0, 0], 480, 314);

      if (MSInterface.Bounds.X2 >= 640) and (MSInterface.Bounds.Y2 >= 481)  then
        Self.Bounds := MSInterface.CreateBounds([0, -1, 0, 0], 600, 392);

      if (MSInterface.Bounds.X2 >= 800) and (MSInterface.Bounds.Y2 >= 601) then
        Self.Bounds := MSInterface.CreateBounds([0, -1, 0, 0], 720, 470);

      if (MSInterface.Bounds.X2 >= 1024) and (MSInterface.Bounds.Y2 >= 769) then
        Self.Bounds := MSInterface.CreateBounds([0, -1, 0, 0], 850, 556);
      //xx //846, 800 // TODO fix dynamic adjusting?

      end;

  end;

  with Self.Bounds do
  begin


    Self.MouldsArea := TBox.Create(X1 + 134, Y1 + 129, X2-36, Y2-20);

    Self.CommissionArea := TBox.Create(X1 + 9, Y1 + 240, X2-360, Y2-9);
    Self.Atrribute1.Bounds := TBox.Create(X1 + 16, Y1 + 263, X2-365, Y2-34);
    Self.Atrribute2.Bounds := TBox.Create(X1 + 16, Y1 + 281, X2-365, Y2-15);

    Self.SetMouldButton.Bounds := TBox.Create(X1 + 345, Y1 + 78, X2 - 9, Y2 - 199);
    Self.ResetMouldButton.Bounds := TBox.Create(X1 + 345, Y1 + 38, X2 - 9, Y2 - 239);
    boxes := TBoxArray.Create([X1 + 9,Y1 + 118], 1, 3, 114, 37, [0, 4]);
    Self.MouldSlots := TBoxArray.Create([X1 + 135,Y1 + 130], 1, 4, 300, 42, [0, -2]);

    if (MSInterface.Bounds.X2 >= 640) and (MSInterface.Bounds.Y2 >= 481) then
    begin
      Self.MouldsArea := TBox.Create(X1 + 134, Y1 + 131, X2-36, Y2-20);
      boxes := TBoxArray.Create([X1 + 9,Y1 + 120], 1, 3, 114, 39, [0, 4]);
      Self.MouldSlots := TBoxArray.Create([X1 + 135,Y1 + 132], 1, 6, 300, 44, [0, -2]);
      Self.SetMouldButton.Bounds := TBox.Create(X1 + 465, Y1 + 80, X2 - 9, Y2 - 275);
      Self.ResetMouldButton.Bounds := TBox.Create(X1 + 465, Y1 + 40, X2 - 9, Y2 - 315);

      Self.CommissionArea := TBox.Create(X1 + 9, Y1 + 40, X2-474, Y2-275);
      Self.Atrribute1.Bounds := TBox.Create(Self.CommissionArea.X1 + 6, Self.CommissionArea.Y1 + 30, Self.CommissionArea.X2-9, Self.CommissionArea.Y2 - 30);
      Self.Atrribute2.Bounds := TBox.Create(Self.CommissionArea.X1 + 6, Self.CommissionArea.Y1 + 50, Self.CommissionArea.X2-9, Self.CommissionArea.Y2 - 9);
    end;

    if (MSInterface.Bounds.X2 >= 800) and (MSInterface.Bounds.Y2 >= 601)  then
    begin
      Self.MouldsArea := TBox.Create(X1 + 134, Y1 + 131, X2-36, Y2-20);
      boxes := TBoxArray.Create([X1 + 9,Y1 + 120], 1, 3, 114, 39, [0, 4]);
      Self.MouldSlots := TBoxArray.Create([X1 + 135,Y1 + 132], 1, 6, 300, 44, [0, -2]);
      Self.SetMouldButton.Bounds := TBox.Create(X1 + 585, Y1 + 80, X2 - 9, Y2 - 353);
      Self.ResetMouldButton.Bounds := TBox.Create(X1 + 585, Y1 + 40, X2 - 9, Y2 - 393);

      Self.CommissionArea := TBox.Create(X1 + 9, Y1 + 40, X2-585, Y2-353);
      Self.Atrribute1.Bounds := TBox.Create(Self.CommissionArea.X1 + 6, Self.CommissionArea.Y1 + 30, Self.CommissionArea.X2-9, Self.CommissionArea.Y2 - 30);
      Self.Atrribute2.Bounds := TBox.Create(Self.CommissionArea.X1 + 6, Self.CommissionArea.Y1 + 50, Self.CommissionArea.X2-9, Self.CommissionArea.Y2 - 9);
    end;

    if (MSInterface.Bounds.X2 >= 1024) and (MSInterface.Bounds.Y2 >= 769) then
    begin
      Self.MouldsArea := TBox.Create(X1 + 134, Y1 + 133, X2-36, Y2-20);
      boxes := TBoxArray.Create([X1 + 9,Y1 + 122], 1, 3, 114, 44, [0, 5]);
      Self.MouldSlots := TBoxArray.Create([X1 + 135,Y1 + 132], 1, 6, 300, 44, [0, -2]);
      Self.SetMouldButton.Bounds := TBox.Create(X1 + 715, Y1 + 82, X2 - 9, Y2 - 437);
      Self.ResetMouldButton.Bounds := TBox.Create(X1 + 715, Y1 + 42, X2 - 9, Y2 - 477);

      Self.CommissionArea := TBox.Create(X1 + 9, Y1 + 42, X2-715, Y2-437);
      Self.Atrribute1.Bounds := TBox.Create(Self.CommissionArea.X1 + 6, Self.CommissionArea.Y1 + 30, Self.CommissionArea.X2-9, Self.CommissionArea.Y2 - 30);
      Self.Atrribute2.Bounds := TBox.Create(Self.CommissionArea.X1 + 6, Self.CommissionArea.Y1 + 50, Self.CommissionArea.X2-9, Self.CommissionArea.Y2 - 9);

    end;
  end;

  Self.Scroll.Area := Self.MouldsArea;
  Self.Scroll.Setup();
  Self.Title.Setup(Self.Bounds);

  Self.SetMouldButton.EnabledColors := [[$0F1043, 0], [$23269F, 0.227]];
  for mouldtype := Low(ERSGiantsFoundryMouldType) to High(ERSGiantsFoundryMouldType) do
  begin
    Self.MouldTypeButtons[mouldtype].Bounds := boxes[Ord(mouldtype)];
    Self.MouldTypeButtons[mouldtype].EnabledColors := [[$344049, 0.000], [$333E48, 0.000]];
  end;

end;

function TRSGiantsFoundrySetup.SelectMouldType(mouldtype: ERSGiantsFoundryMouldType): Boolean;
begin
  if Self.MouldTypeButtons[mouldtype].Enabled then Exit(True);

  Result := Self.MouldTypeButtons[mouldtype].Enable;
end;

(*
## GiantsFoundrySetup._SetupMoulds
```pascal
procedure TRSGiantsFoundrySetup._SetupMoulds();
```
Internal method used to populate the mould database.
This is automatically called for you.
*)

procedure TRSGiantsFoundrySetup._SetupMoulds();
var
  m: TRSGiantsFoundryMould;
begin
  // DEFAULT FORTES
  m := ['Chopper Forte', ERSGiantsFoundryMouldType.FORTE, 8, 0, 0, 0, 8, 0, 1, True];
  Self.AvailableMoulds += m;

  m := ['Dagger Forte', ERSGiantsFoundryMouldType.FORTE, 0, 8, 0, 0, 0, 8, 1, True];
  Self.AvailableMoulds += m;

  // PURCHASABLE FORTES
  m := ['Choppa!', ERSGiantsFoundryMouldType.FORTE, 10, 0, 8, 0, 0, 0, 30, False];
  Self.AvailableMoulds += m;

  m := ['Medius', ERSGiantsFoundryMouldType.FORTE, 0, 10, 0, 8, 0, 0, 45, False];
  Self.AvailableMoulds += m;

  m := ['Juggernaut Forte', ERSGiantsFoundryMouldType.FORTE, 10, 0, 0, 0, 10, 0, 65, False];
  Self.AvailableMoulds += m;

  // DEFAULT BLADES
  m := ['Broad Blade', ERSGiantsFoundryMouldType.BLADE, 0, 0, 8, 0, 8, 0, 1, True];
  Self.AvailableMoulds += m;

  m := ['Narrow Blade', ERSGiantsFoundryMouldType.BLADE, 0, 0, 0, 8, 0, 8, 1, True];
  Self.AvailableMoulds += m;

  // PURCHASABLE BLADES
  m := ['Razor Blade', ERSGiantsFoundryMouldType.BLADE, 0, 0, 0, 10, 0, 10, 35, False];
  Self.AvailableMoulds += m;

  m := ['Defender Base', ERSGiantsFoundryMouldType.BLADE, 10, 0, 10, 0, 10, 0, 50, False];
  Self.AvailableMoulds += m;

  // DEFAULT TIPS
  m := ['Saw Tip', ERSGiantsFoundryMouldType.TIP, 0, 0, 0, 0, 0, 8, 1, True];
  Self.AvailableMoulds += m;

  m := ['Flat Tip', ERSGiantsFoundryMouldType.TIP, 0, 0, 0, 0, 8, 0, 1, True];
  Self.AvailableMoulds += m;

  // PURCHASABLE TIPS
  m := ['Spiker!', ERSGiantsFoundryMouldType.TIP, 8, 0, 0, 0, 0, 10, 40, False];
  Self.AvailableMoulds += m;

  m := ['Corrupted Point', ERSGiantsFoundryMouldType.TIP, 0, 10, 0, 8, 0, 0, 55, False];
  Self.AvailableMoulds += m;

  m := ['Serrated Tip', ERSGiantsFoundryMouldType.TIP, 0, 0, 0, 10, 0, 10, 60, False];
  Self.AvailableMoulds += m;

  m := ['The Point!', ERSGiantsFoundryMouldType.TIP, 0, 0, 10, 0, 10, 0, 70, False];
  Self.AvailableMoulds += m;
end;

(*
## GiantsFoundrySetup.IsOpen
```pascal
function TRSGiantsFoundrySetup.IsOpen(): Boolean;
```
Returns true if the mould setup interface is open.

Example:
```pascal
WriteLn GiantsFoundrySetup.IsOpen();
```
*)

function TRSGiantsFoundrySetup.IsOpen(): Boolean;
begin
  Result := Self.Title.GetTitle().Contains('Foundry Mould Setup', True);
end;

(*
## GiantsFoundrySetup.WaitOpen
```pascal
function TRSGiantsFoundrySetup.WaitOpen(time: Integer = 600; interval: Integer = -1): Boolean;
```
Returns true if the mould setup opens within `time` milliseconds.

Example:
```pascal
WriteLn GiantsFoundrySetup.WaitOpen();
```
*)

function TRSGiantsFoundrySetup.WaitOpen(time: Integer; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.IsOpen(), interval, time);
end;

(*
## GiantsFoundrySetup.Close
```pascal
function TRSGiantsFoundrySetup.Close(escape: Boolean): Boolean;
function TRSGiantsFoundrySetup.Close(escapeProbability: Double = BioHash): Boolean; overload;
```
Closes the {ref}`GiantsFoundrySetup` interface, depending on `escape` the function will either
press escape or click the close button.

Example:
```pascal
WriteLn GiantsFoundrySetup.Close();
```
*)

function TRSGiantsFoundrySetup.Close(escape: Boolean): Boolean;
begin
  Result := Self.Title.Close(escape);
end;

function TRSGiantsFoundrySetup.Close(escapeProbability: Single = -1): Boolean; overload;
begin
  Result := Self.Title.Close(escapeProbability);
end;

function TRSGiantsFoundrySetup.Find(mould: TRSGiantsFoundryMould): Boolean;
var
  mouldbox: TBox;
begin
  for mouldbox in Self.FindMouldBoundaries do
  begin
    Writeln(mouldbox);
    if OCR.Recognize(mouldbox, RSFonts.PLAIN_12, [RSFonts.ORANGE], 0).Contains(mould.Name) then
    begin
      Writeln('Found Mould!!');
      Result := True;
    end;
  end;
end;

function TRSGiantsFoundrySetup.FindScroll(mould: TRSGiantsFoundryMould): Integer;
var
  next: Integer;
  down: Boolean;
begin
  if not Self.Scroll.CanScroll() then Exit(-1);

  if not Self.SelectMouldType(mould.MouldType) then Exit(-1);

  Result := Self.Scroll.GetLevel();
  down := (Result > 0) or RandomBoolean(0.5);

  if Self.Find(mould) then Exit;

  repeat
    if down then next := Result - 5
    else next := Result + 5;

    Result := Self.Scroll.SetLevel(next);
    if Self.Find(mould) then Exit;

    if not Self.IsOpen() then Exit(-1); //failsafe
  until not InRange(Result, 1, 99);

  down := not down;
  repeat
    if down then next := Result - 5
    else next := Result + 5;

    Result := Self.Scroll.SetLevel(next);
    if Self.Find(mould) then Exit;

    if not Self.IsOpen() then Exit(-1);
  until not InRange(Result, 1, 99);

  Result := -1;
end;

(*
## GiantsFoundry.SetupMoulds
```pascal
function TRSGiantsFoundry.SetupMoulds(commission: TRSGiantsFoundryCommission): Boolean;
```
Automatically selects the optimal moulds for the current commission.

Example:
```pascal
var commission: TRSGiantsFoundryCommission;
begin
  commission := GiantsFoundry.GetCommission();

  if GiantsFoundry.SetupMoulds(commission, 75) then
    WriteLn('Successfully configured optimal moulds');
end;
```
*)

function TRSGiantsFoundry.SetupMoulds(commission: TRSGiantsFoundryCommission): Boolean;
begin

end;

(*
## GiantsFoundrySetup.GetCommission
```pascal
function TRSGiantsFoundrySetup.GetCommission(): TRSGiantsFoundryCommission;
```
Attempts to read the commision section in the bottom left
of the mould setup interface to determine what commision we have and return it.
*)

function TRSGiantsFoundrySetup.GetCommision(): TRSGiantsFoundryCommission;
begin
  Result.Attribute1 := GiantsFoundry._StringToAttribute(OCR.Recognize(Self.Atrribute1.Bounds, RSFonts.PLAIN_12, [RSFonts.ORANGE], 0));
  Result.Attribute2 := GiantsFoundry._StringToAttribute(OCR.Recognize(Self.Atrribute2.Bounds, RSFonts.PLAIN_12, [RSFonts.ORANGE], 0));
end;

(*
## GiantsFoundrySetup.GetAttributeScore
```pascal
function TRSGiantsFoundrySetup.GetAttributeScore():
```
Attempts to read the a attribute from the commision section in the bottom left
to determine what commision we have and return it.
*)

function TRSGiantsFoundrySetup.GetAttributeScore(attribute: TRSGiantFoundrySetupAttribute): Integer;
begin
  Result := OCR.Recognize(attribute.Bounds, RSFonts.PLAIN_12, [RSFonts.ORANGE], 0).ExtractInteger();
end;



procedure TRSGiantsFoundrySetup.Draw(img: TImage);
var
  i: Integer;
begin
  //if not Self.IsOpen() then Exit;

  img.DrawColor := $00FFFF;
  img.DrawBox(Self.Bounds);
  //img.DrawBoxArray(Self.MouldSlots, False);
  img.DrawBoxArray(Self.FindMouldBoundaries, False);
  img.DrawBox(Self.SetMouldButton.Bounds);
  img.DrawBox(Self.ResetMouldButton.Bounds);
  img.DrawBox(Self.CommissionArea);
  img.DrawBox(Self.MouldsArea);
  img.DrawColor := $854F31;

  img.DrawBox(Self.Atrribute1.Bounds);
  img.DrawBox(Self.Atrribute2.Bounds);

  Self.Scroll.Draw(img);
  for i := 0 to High(Self.MouldTypeButtons) do
    Self.MouldTypeButtons[i].Draw(img);

end;

procedure TRSGiantsFoundrySetup.ShowOnTarget();
var
  img: TImage;
begin
  img := Target.GetImage();
  Self.Draw(img);
  img.Show();
end;
var
(*
## GiantsFoundrySetup variable
Global {ref}`TRSGiantsFoundrySetup` variable.
*)
  GiantsFoundrySetup: TRSGiantsFoundrySetup;
