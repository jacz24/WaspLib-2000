(*
# Walker
This file is responsible for our walking system.
It is heavily inspired in the original TRSWalker by [slacky](https://slacky.one/) and it's future
iterations made by Olly.
*)

{$DEFINE WL_WALKER_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
(*
## type PRSWalker
TRSWalker pointer.
*)
  PRSWalker = ^TRSWalker;

(*
## type TRSWalkerEvent
Callback object method to use while walking. This can be used to perform custom tasks while walking.

Example:
```pascal
procedure TRSWalker.WalkerTasks(walker: PRSWalker; position, destination: TPoint);
begin
  Antiban.RandomTab();
end;

begin
  //this assumes walker is already setup.
  walker.OnWaitMoving := @walker.WalkerTasks;
end;
```
*)
  TRSWalkerEvent          = procedure(walker: PRSWalker; position, destination: TPoint) of object;
  TWalkerPositionFunction = function (): TPoint of object;
  TWalkerHeightFunction   = function (pt: TPoint = [0,0]; global: Boolean = True): Single of object;
  TWalkerGetLocalFunction = function (pt: TPoint; offset: TPoint = [0,0]): TPoint of object;

(*
## TRSWalker
TRSWalker is the record responsible for walking.
To work you need to set it up with something that gives it a position function
as by itself it doesn't really do anything.

Once you have a function that gives you an accurate position, you can pass it to
into a `TRSWalker` variable or into the {ref}`Walker` one, either directly or
via the {ref}`Walker.Setup` method.
*)
  TRSWalker = record
    Name: String;

    Position: TWalkerPositionFunction;
    Height:   TWalkerHeightFunction;
    GetLocal: TWalkerGetLocalFunction;

    MinEnergy, ClickRandomness, MouseAheadTimer: Integer;

    ScreenWalk, AdaptiveWalk, FancyMouse, Walking, RedClicked: Boolean;

    AdaptiveToggleDistances, AdaptiveDistance: TPoint;


    WalkUpText, TargetUpText, ActionUpText: TStringArray;

    WebGraph: PWebGraph;
    MapImage: TImage;

    OnWalkEvent, OnWaitMovingEvent: TRSWalkerEvent;

    //Don't touch:
    _Index: Integer;
    _Path: TGraphNodeArray;
    _Node: EGraphNode;
    _Flag: TPoint;
  end;

{$H-}
{%codetools off}
function TRSWalker.DummyHeight(pt: TPoint = [0,0]; global: Boolean = True): Single; begin Result := pt.X; end;
function TRSWalker.DummyGetLocal(pt: TPoint; offset: TPoint = [0,0]): TPoint; begin Result := pt+offset; end;
{%codetools on}
{$H+}


(*
## Walker.Setup
```pascal
procedure TRSWalker.Setup(position: TWalkerPositionFunction; height: TWalkerHeightFunction; getLocal: TWalkerGetLocalFunction; graph: PWebGraph; mapImage: TImage);
```
Method responsible for setting up the {ref}`TRSWalker` variable.
All parameters of this function can be `nil` except for `position`.
Without a `position` callback you cannot use `TRSWalker`.

The following is purely an example, you never have to do this since `Map.Setup`
already does this for you anyway:
```pascal
Map.Setup(ERSChunk.CATACOMBS_OF_KOUREND);
Walker.Setup(@Map.Position, @Map.Height, @Map.Loader.GetLocal, @Map.Loader.Graph, @Map.Loader.Map);
```
*)
procedure TRSWalker.Setup(position: TWalkerPositionFunction; height: TWalkerHeightFunction; getLocal: TWalkerGetLocalFunction; graph: PWebGraph; mapImage: TImage);
begin
  Self.Name := 'Walker';
  Self.Position := @position;

  if @height <> nil then
    Self.Height := @height else Self.Height := @Self.DummyHeight;
  if @getLocal <> nil then
    Self.GetLocal := @getLocal else Self.GetLocal := @Self.DummyGetLocal;
  if Self.AdaptiveDistance = Default(TPoint) then
    Self.AdaptiveDistance := [25,110];

  Self.WalkUpText := ['Walk here', 'alk her'];
  Self.AdaptiveWalk := True;
  Self.WebGraph := graph;
  Self.MapImage := mapImage;
end;


(*
## Walker Conversions
```pascal
function TRSWalker.Point2MM(me, pt: TPoint; radians: Double): TPoint;
function TRSWalker.Point2MMVec(me, pt: TPoint; radians: Double): Vector2;
function TRSWalker.Points2MM(me: TPoint; tpa: TPointArray; radians: Double): TPointArray;
function TRSWalker.GetLocalEx(tpa: TPointArray; offset: TPoint = [0,0]): TPointArray;
function TRSWalker.GetQuadMS(me, mapPoint: TPoint; height: Double = 0; offset: Vector3 = [0,0,0]; radians: Single = $FFFF): TQuad;
function TRSWalker.MM2Map(me, minimapPoint: TPoint; radians: Single = $FFFF): TPoint;
```
Used to convert coordinates from `TRSWalker` to the minimap or the mainscreen.

Example:
```pascal
//assuming walker is already setup...
me := Walker.Position();
ShowOnTarget(Walker.GetQuadMS(me, me + [4,0])); //should show you the tile to your right.
```
*)
function TRSWalker.Point2MM(me, pt: TPoint; radians: Double): TPoint;
begin
  Result := pt - me + Minimap.Center;
  Result := Result.Rotate(radians, Minimap.Center);
end;

function TRSWalker.Point2MMVec(me, pt: TPoint; radians: Double): TVector2;
begin
  with pt - me + Minimap.Center do
    Result := ToVec2().Rotate(radians, Minimap.Center);
end;

function TRSWalker.Points2MM(me: TPoint; tpa: TPointArray; radians: Double): TPointArray;
var
  pt: TPoint;
begin
  for pt in tpa do
    Result += Self.Point2MM(me, pt, radians);
end;

function TRSWalker.FilterToMM(me: TPoint; dotFilter: TRSDotFilter; radians: Single): TRSDotFilter;
var pt: TPoint;
begin
  if dotFilter.Circle <> [] then
    with Self.Point2MM(me, dotFilter.Circle.Center, radians) do
      Result.Circle := [X, Y, dotFilter.Circle.Radius];

  for pt in Self.Points2MM(me, dotFilter.Poly, radians) do
    Result.Poly += pt;
  Result.Inside  := dotFilter.Inside;
  Result.Timeout := dotFilter.Timeout;
  Result.Timer   := dotFilter.Timer;
end;

function TRSWalker.FiltersToMM(me: TPoint; dotFilters: TRSDotFilterArray; radians: Single): TRSDotFilterArray;
var
  i: Int32;
begin

  for i := High(dotFilters) downto 0 do
  begin
    if dotFilters[i].IsExpired() then
    begin
      Delete(dotFilters, i, 1);
      Continue;
    end;

    Result += Self.FilterToMM(me, dotFilters[i], radians);
  end;
end;

function TRSWalker.GetLocalEx(tpa: TPointArray; offset: TPoint = [0,0]): TPointArray;
var
  pt: TPoint;
begin
  for pt in tpa do
    Result += Self.GetLocal(pt, offset);
end;

function TRSWalker.GetQuadMS(me, mapPoint: TPoint; size: TVector2; radians: Single): TQuad;
var
  vector: TVector2;
  corners: TVector3Array;
  h: Single;
  pt, currLoc: TPoint;
  arr: TPointArray;
begin
  if not me.InRange(mapPoint, Projection.RENDER_DISTANCE) then
    Exit;
  vector := Self.Point2MMVec(me, mapPoint, radians);
  pt := vector.ToPoint();

  vector := vector.Rotate(-radians, Minimap.Center.ToVec2());
  me := Self.GetLocal(me);

  h := Self.Height(me, False);

  currLoc := me + vector.ToPoint() - Minimap.Center;

  size.X := size.X*2;
  size.Y := size.Y*2;

  corners := [
    [vector.X-size.X, vector.Y-size.Y, Self.Height(currLoc + [-1,-1], False) - h],
    [vector.X+size.X, vector.Y-size.Y, Self.Height(currLoc + [1,-1],  False) - h],
    [vector.X+size.X, vector.Y+size.Y, Self.Height(currLoc + [1,1],   False) - h],
    [vector.X-size.X, vector.Y+size.Y, Self.Height(currLoc + [-1,1],  False) - h]
  ];

  arr := Projection.Run(corners, radians);
  Result := [arr[0], arr[1], arr[2], arr[3]];
end;

function TRSWalker.GetCuboidMS(me, mapPoint: TPoint; size: TVector3; radians: Single): TCuboid;
var
  vector: TVector2;
  corners: TVector3Array;
  h: Single;
  pt, currLoc: TPoint;
  arr: TPointArray;
begin
  if not me.InRange(mapPoint, Projection.RENDER_DISTANCE) then Exit;
  vector := Self.Point2MMVec(me, mapPoint, radians);
  pt := vector.ToPoint();

  vector := vector.Rotate(-radians, Minimap.Center.ToVec2());
  me := Self.GetLocal(me);

  h := Self.Height(me, False);

  currLoc := me + vector.ToPoint() - Minimap.Center;

  size.X := size.X*2;
  size.Y := size.Y*2;

  corners := [
    [vector.X-size.X, vector.Y-size.Y, Self.Height(currLoc + [-1,-1], False) - h],
    [vector.X+size.X, vector.Y-size.Y, Self.Height(currLoc + [1,-1],  False) - h],
    [vector.X+size.X, vector.Y+size.Y, Self.Height(currLoc + [1,1],   False) - h],
    [vector.X-size.X, vector.Y+size.Y, Self.Height(currLoc + [-1,1],  False) - h],

    [vector.X-size.X, vector.Y-size.Y, Self.Height(currLoc + [-1,-1], False) - h + size.Z],
    [vector.X+size.X, vector.Y-size.Y, Self.Height(currLoc + [1,-1],  False) - h + size.Z],
    [vector.X+size.X, vector.Y+size.Y, Self.Height(currLoc + [1,1],   False) - h + size.Z],
    [vector.X-size.X, vector.Y+size.Y, Self.Height(currLoc + [-1,1],  False) - h + size.Z]
  ];

  arr := Projection.Run(corners, radians);
  Result := [
    [arr[4], arr[5], arr[6], arr[7]], [arr[0], arr[1], arr[2], arr[3]]
  ];
end;

function TRSWalker.MM2Map(me, minimapPoint: TPoint; radians: Single): TPoint;
begin
  Result := me + minimapPoint - Minimap.Center;
  Result := Result.Rotate(-radians, me);
end;


function TRSWalker.FindFlag(me: TPoint; out flag: TPoint; radians: Single): Boolean;
begin
  Result := Minimap.FindFlag(flag);
  if Result then
    flag := Self.MM2Map(me, flag, radians);
end;

function TRSWalker.WaitFlag(out flag: TPoint; radians: Single): Boolean;
begin
  Result := SleepUntil(Self.FindFlag(Self.Position(), flag, radians), 100, 600);
end;

function TRSWalker.FlagMoved(out flag: TPoint; radians: Single): Boolean;
var
  newFlag: TPoint;
begin
  Result := SleepUntil(
              Self.FindFlag(Self.Position(), newFlag, radians) and
              not newFlag.InRange(flag, 4),
              100,
              600
            );

  flag := newFlag;
end;



(*
## TRSWalker.InRange
```pascal
function TRSWalker.InRangeEx(me, coordinate: TPoint; distance: Integer = 4): Boolean;
function TRSWalker.InRange(coordinate: TPoint; distance: Integer = 4): Boolean;
```
Returns True/False if we are within `distance` of a certain `coordinate`.
`distance` is measured in pixels and in a radial way.
*)
function TRSWalker.InRangeEx(me, coordinate: TPoint; distance: Integer = 4): Boolean;
begin
  Result := me.DistanceTo(coordinate) <= distance;
end;

function TRSWalker.InRange(coordinate: TPoint; distance: Integer = 4): Boolean;
begin
  Result := Self.InRangeEx(Self.Position(), coordinate, distance);
end;


(*
## Walker.CheckEnergy
```pascal
procedure TRSWalker.CheckEnergy();
```
Internal method used to check and enable the player run.
You will probably never need to call this directly.

The values used are hardcoded and if you don't like them,
it's recommended you override the method.
The following example shows how one could override the function to enable
run at 50% energy everytime, keep in mind though,
you shouldn't do this, you should add randomness to it!

Example:
```pascal
Map.Walker.MinEnergy := 10;
Map.Walker.CheckEnergy();
```
*)
procedure TRSWalker.CheckEnergy();
begin
  if Minimap.EnergyEnabled() then Exit;
  if Minimap.GetLevel(ERSMinimapOrb.ENERGY) < Self.MinEnergy then Exit;

  Self.MinEnergy := RandomMode(40, 10, 100);
  Minimap.EnableEnergy();
end;

(*
## Walker.AdaptiveWalkCheck
```pascal
procedure TRSWalker.AdaptiveWalkCheck(position: TPoint);
```
Internal method used to check if adaptive walk should toggle and toggle TRSWalker.ScreenWalk.
You will probably never need to call this directly.
*)
procedure TRSWalker.AdaptiveWalkCheck(position: TPoint);
var
  wasEnabled: Boolean;
begin
  wasEnabled := Self.ScreenWalk;
  Self.ScreenWalk := False;
  if ((position.DistanceTo(Self._Path[0].Node) < Self.AdaptiveToggleDistances.X) or
      (position.DistanceTo(Self._Path[High(Self._Path)].Node) < Self.AdaptiveToggleDistances.Y)) and
     (Random() > 0.05) then
    Self.ScreenWalk := True

  else if Random() < 0.02 then
    Self.ScreenWalk := True;

  if (not wasEnabled) and (Self.ScreenWalk) and (Self.FancyMouse) and (Random() < 0.75) and Minimap.Contains(Target.MouseXY) then
    Self.DoMouseAhead(position, True);
end;

(*
## Walker.DoMouseAhead
```pascal
procedure TRSWalker.DoMouseAhead(position: TPoint; forced: Boolean = False);
```
Internal method used to pre-hover the next walking step.
You will probably never need to call this directly.
*)
procedure TRSWalker.DoMouseAhead(position: TPoint; forced: Boolean = False);
var
  flag: TPoint;
  dist: Integer;

  procedure MouseToNextPoint(myPos: TPoint);
  var
    mmPos, tmp: TPoint;
    idx: Integer;
    speed: Double;
    angle, h, diff: Single;
  begin
    angle := Minimap.CompassRadians;
    idx := Self._Index;

    while (idx < High(Self._Path)) and Self.IsWalkable(Self._Path[idx+1].Node, myPos, tmp, angle) do
      Inc(idx);

    if (idx = High(Self._Path)) and (Random(10) > 2) then Exit();

    mmPos := Self._Path[idx].Node - myPos + Minimap.Center;
    mmPos := mmPos.Rotate(angle, Minimap.Center);

    if Self.ScreenWalk then
    begin
      h := Self.Height(myPos);
      diff := Self.Height(Self.MM2Map(myPos, mmPos, angle));
      mmPos := Minimap.Vector2MSQuad(mmPos.ToVec3(h), angle, [1,1], [0,0,-diff]).Mean;
    end;

    speed := Target.Options.MouseSpeed;
    Target.Options.MouseSpeed := Random(6,10);
    if not Self.ScreenWalk then
      Mouse.Move(Box(mmPos, Random(5,16), Random(5,16)))
    else
      Mouse.Move(Box(mmPos, Random(15,36), Random(15,36)));
    Target.Options.MouseSpeed := speed;
  end;
begin
  if (not forced) then
    if (GetTimeRunning() < Self.MouseAheadTimer) or (not Minimap.FindFlag(Flag)) then
      Exit();

  dist := Trunc(flag.DistanceTo(Minimap.Center));
  if System.InRange(dist, Random(5,10), Random(60,70)) then
    MouseToNextPoint(position);

  Self.MouseAheadTimer := GetTimeRunning() + RandomMode(0,50,500);
  if Self.ScreenWalk then
    Self.MouseAheadTimer += RandomMode(0,50,500);
end;

(*
## Walker.WaitMoving
```pascal
procedure TRSWalker.WaitMoving(destination: TPoint; minDist: Integer);
procedure TRSWalker.WaitMoving(time: Integer = 20000; doAntiban: Boolean = True); overload;
```
Internal method used to wait while we are moving using walker.
You will probably never need to call this directly.

This is where TRSWalker.OnWaitMoving are called.
*)
procedure TRSWalker.WaitMoving(destination: TPoint; minDist: Integer);
var
  timeout, countdown: TCountDown;
  position: record Current, Previous: TPoint; end;
  awct: Int64;
begin
  timeout.Start(Round(GaussRand(20000, 25000)));
  countdown.Start(Round(GaussRand(500, 1500)));

  // initial timeout needs to be longer, as we might not have started walking yet.
  countdown.Extend(Round(GaussRand(2500, 3500)));

  position.Previous := Self.Position();
  position.Current := position.Previous;

  // Break from the loop if:
  // - Haven't moved in 500ms
  // - Been walking for over 20 seconds
  // - Within `minDist` to the destination
  repeat
    Self.CheckEnergy();

    position.Previous := position.Current;
    position.Current := Self.Position();
    if position.Current <> position.Previous then
      countdown.Restart();

    if @Self.OnWaitMovingEvent <> nil then
      Self.OnWaitMovingEvent(@Self, position.Current, destination);

    if (Self.AdaptiveWalk) and (Time() > awct) then
    begin
      Self.AdaptiveWalkCheck(Position.Current);
      awct := Time() + 1000;
    end;

    if Self.FancyMouse then Self.DoMouseAhead(position.Current);
    if not Self.Walking then Break;

    Sleep(50, 150);
  until timeout.IsFinished or countdown.IsFinished or position.Current.InRange(destination, minDist);
end;

procedure TRSWalker.WaitMoving(time: Integer = 20000; doAntiban: Boolean = True); overload;
var
  timeout, countdown: TCountDown;
  moving: Boolean;
begin
  timeout.Start(time);
  countdown.Start(500);

  repeat
    if doAntiban then
      Antiban.WalkingTasks();

    moving := Minimap.IsPlayerMoving();

    if moving then
      countdown.Restart(0, 1000);

  until timeout.IsFinished or (not moving and countdown.IsFinished) or not Minimap.HasFlag();
end;


(*
## Walker.Click
```pascal
function TRSWalker.Click(minimapPoint: TPoint; Randomness: Integer): Boolean;
```
Internal method used by walker to handle clicking while walking.
You will probably never need to call this directly.

If you wish to modify certain walker behaviors, it can be a good approach to override this function.
*)
function TRSWalker.Click(me, mapPoint, minimapPoint: TPoint; randomness: Integer): Boolean;
var
  pt: TPoint;
  upText: String;
  hoveringTarget: Boolean;
  quad: TQuad;
  tile: TPointArray;
begin
  Self.RedClicked := False;

  if MainScreen.IsUpText('>') and not Self.ActionUpText.AnyContains('>') then
  begin
    ChooseOption.Select('Cancel');
    Exit;
  end;

  Result := True;
  Self.CheckEnergy();

  if Self.ScreenWalk then
  begin
    if randomness = 0 then
      pt := mapPoint
    else
      pt := mapPoint.Random(-randomness, randomness);

    if not me.InRange(pt, Projection.RENDER_DISTANCE) then
      Exit;

    quad := Self.GetQuadMS(me, pt, [0.9,0.9], Minimap.CompassRadians);
    tile := quad.Corners.Connect().ShapeFill();
    tile := MainScreen.Filter(tile);
    if tile = [] then Exit;

    Mouse.Move(tile.RandomMean());
    upText := MainScreen.UpText;

    hoveringTarget := upText.ContainsAny(Self.TargetUpText);

    if hoveringTarget and (Self.ActionUpText <> []) then
    begin
      hoveringTarget := upText.ContainsAny(Self.ActionUpText);

      if not hoveringTarget then
      begin
        Self.RedClicked := ChooseOption.Select(Self.ActionUpText);
        if Self.RedClicked then
          Self.Walking := False;
        Exit(Self.RedClicked);
      end;
    end
    else
    if not upText.ContainsAny(Self.WalkUpText) then
    begin
      if not ChooseOption.Open() then Exit;
      if not ChooseOption.Find(Self.TargetUpText, True, False) then
        Exit(ChooseOption.Select(Self.WalkUpText + ['Walk here']));

      if Self.ActionUpText <> [] then
        Self.RedClicked := ChooseOption.Select(Self.ActionUpText)
      else
        Self.RedClicked := ChooseOption.Select(Self.TargetUpText);

      if Self.RedClicked then
        Self.Walking := False;
      Exit(Self.RedClicked);
    end;
  end
  else
    Mouse.Move(Minimap.RandomPoint(minimapPoint, randomness));

  if randomness = 0 then
    Mouse.Click(EMouseButton.LEFT)
  else
    Biometrics.Click(EMouseButton.LEFT);

  Self.RedClicked := Self.ScreenWalk and hoveringTarget and MainScreen.RedClicked();

  if Self.RedClicked then
    Self.Walking := False;
end;

(*
## Walker.IsWalkable
```pascal
function TRSWalker.IsWalkable(mapPoint: TPoint; me: TPoint; out mmPoint: TPoint; radians: Single): Boolean;
```
Internal method used by walker to decide if the destination point is within 1 click reach.
You will probably never need to call this directly.
*)
function TRSWalker.IsWalkable(mapPoint, me: TPoint; out mmPoint: TPoint; radians: Single): Boolean;
var
  tile: TPointArray;
  count: Integer;
begin
  mmPoint := Self.Point2MM(me, mapPoint, radians);
  if not Self.ScreenWalk then
    Exit(Minimap.Polygon.Expand(-1).Contains(mmPoint));

  tile := Self.GetQuadMS(me, mapPoint, [0.9,0.9], radians).Corners.Connect().ShapeFill();
  count := Length(tile);

  tile := MainScreen.Filter(tile);
  if tile = [] then Exit;

  Result := (Length(tile) / count * 100) > 35; //tile is 35% visible
end;

function TRSWalker._WalkStepHelper(me, mapPoint: TPoint; randomness: Integer; out minimapPoint: TPoint; out shouldExit: Boolean): Boolean;
var
  t: UInt64;
begin
  shouldExit := True;
  t := Time();
  if @Self.OnWalkEvent <> nil then Self.OnWalkEvent(@Self, me, mapPoint);
  if Time() - t > 100 then me := Self.Position(); //Check if event took too long and update position.

  if not Self.Walking or not Self.IsWalkable(mapPoint, me, minimapPoint, Minimap.CompassRadians) then
    Exit(not Self.Walking);

  if Minimap.Center.InRange(minimapPoint, 3) then
    Exit(True);

  shouldExit := False;
  Result := Self.Click(me, mapPoint, minimapPoint, randomness);
end;


(*
## Walker.WalkStep
```pascal
function TRSWalker.WalkStep(me: TPoint; index, minDist: Integer): Boolean;
```
Internal method used by walker while walking a path.
You will probably never need to call this directly.
*)
function TRSWalker.WalkStep(me: TPoint; index, minDist: Integer): Boolean;
var
  mapPt, minimapPt: TPoint;
  shouldExit: Boolean;
  randomness: Integer;
begin
  mapPt := Self._Path[index].Node;

  if index = High(Self._Path) then
    randomness := 0
  else
    randomness := Self.ClickRandomness;

  Result := Self._WalkStepHelper(me, mapPt, randomness, minimapPt, shouldExit);

  if shouldExit then Exit;
  if not Result then Exit;

  if index <> High(Self._Path) then
  begin
    minDist := Round(Minimap.Center.DistanceTo(minimapPt));
    if (Random() < 0.15) then // 15% chance of randomness else mean
      minDist := Random(minDist)
    else
      minDist := RandomMean(0, minDist + 10);
  end;

  Self.WaitMoving(mapPt, minDist);
  if index = High(Self._Path) then
    Result := Self.Position().InRange(mapPt, minDist);
end;

function TRSWalker.CrossDoor(me: TPoint; index: Integer; attempts: Integer = 3): Boolean;
var
  tmp: TPoint;
  furthest, doorAttempts: Integer;
  radians: Double;
  mapPt, minimapPt, flag: TPoint;
  shouldExit, handleDoor: Boolean;
  cuboid: TCuboid;
begin
  if attempts = 0 then Exit;
  if index = High(Self._Path) then
    raise GetDebugLn(Self.Name, 'Paths should not end at a door node.');
  WriteLn GetDebugLn(Self.Name, 'Attempting to cross door');

  furthest := index;

  radians := Minimap.CompassRadians;

  while (furthest < High(Self._Path)) and Self.IsWalkable(Self._Path[furthest+1].Node, me, tmp, radians) do
  begin
    if Self._Path[furthest+1].Typ <> EGraphNode.NORMAL then
      Break;
    Inc(furthest);
  end;

  if Biometrics.RandomBoolean(0.002) then
    furthest := Random(index, furthest);

  mapPt := Self._Path[furthest].Node;
  if not Self._WalkStepHelper(me, mapPt, 0, minimapPt, shouldExit) then
    Exit;

  if shouldExit then
    Exit;

  if Self.WaitFlag(flag, radians) then
    handleDoor := not me.InRange(flag, 8) and Self.FlagMoved(flag, radians)
  else
    handleDoor := True;

  Self.WaitMoving(mapPt, 3);

  if not handleDoor and not Self.WebGraph^.WalkableClusters.InSameTPA(Self.Position(), mapPt) then
    handleDoor := True;

  if handleDoor then
  begin
    for doorAttempts := 0 to 2 do
    begin
      WriteLn GetDebugLn(Self.Name, 'Attempt to open door number: ' + ToStr(doorAttempts+1));

      cuboid := Self.GetCuboidMS(Self.Position(), Self._Path[index].Node, [0.6,0.6,4], radians);
      if MainScreen.Interact(cuboid.ShapeFill().RandomMean(), ['Open']) then
      begin
        Self.WaitMoving(Self._Path[index].Node, 3);
        Sleep(600, 1200);
        Break;
      end;
    end;
    WriteLn GetDebugLn(Self.Name, 'Door should now be open.');
  end;

  Result := Self.CrossDoor(Self.Position(), index, Dec(attempts));
end;

function TRSWalker.UseStairs(me: TPoint; index: Integer): Boolean;
var
  direction: String;
begin
  if index = High(Self._Path) then
    raise GetDebugLn(Self.Name, 'Paths should not end at a stairs node.');

  if Abs(Self._Path[index].Node.X - Self._Path[index+1].Node.X) < RSTranslator.MapWidth then
    direction := 'Down';

  Result := me = me; //todo...
end;


function TRSWalker.UseNodeCallback(index: Integer): Boolean;
begin
  if index = High(Self._Path) then
    raise GetDebugLn(Self.Name, 'Paths should not end at a ' + ToStr(Self._Node) + ' node.');
  Result := Self._Path[index].Handle();
end;

function TRSWalker.UseFairyRing(me: TPoint; index: Integer): Boolean;
begin
  if index = High(Self._Path) then
    raise GetDebugLn(Self.Name, 'Paths should not end at a fairy ring node.');
  Result := me = me;
end;



procedure TRSWalker.DrawPath(img: TImage; index: Integer; me: TPoint);
var
  i: Integer;
  path: TPointArray;
  compass: Single;
begin
  compass := Minimap.CompassRadians;
  for i := 0 to High(Self._Path) do
    if me.InRange(Self._Path[i].Node, 90) then
      path += Self.Point2MM(me, Self._Path[i].Node, compass);

  path := Minimap.Filter(path);

  for i := 0 to High(path) do
  begin
    img.DrawColor := $FFFFFF;
    if (i < High(path)) and img.InImage(path[i+1].X, path[i+1].Y) then
      img.DrawLine(path[i], path[i+1]);

    if index = i then
    begin
      img.DrawColor := $FF1010;
      img.DrawBox(TBox.Create(path[i], 2, 2));
    end
    else
    begin
      img.DrawColor := $10FF10;
      img.DrawBox(TBox.Create(path[i], 2, 2));
    end;
  end;
end;

procedure TRSWalker.DebugPath(index: Integer; me: TPoint);
var
  img: TImage;
begin
  img := Target.GetImage();
  Self.DrawPath(img, index, me);
  img.Show();
end;


procedure TRSWalker._WalkPathSetup(path: TGraphNodeArray);
var
  me: TPoint;
  smallSteps: Boolean;
  i, j: Integer;
  line: TPointArray;
begin
  Self.Walking := True;
  Self._Path := [];

  me := Self.Position();

  if not me.InRange(path[0].Node, 3) then
    path := [TGraphNode.Create(me)] + path;

  smallSteps := (Self.ScreenWalk or Self.AdaptiveWalk) and InRange(Options.GetZoomLevel(), 70, 100);

  //Self._Path += path.First;
  for i := 0 to High(path)-1 do
  begin
    if path[i+1].Typ = EGraphNode.TELEPORT then
    begin
      Self._Path += path[i+1];
      Continue;
    end;

    line := TPointArray.CreateFromLine(path[i].Node, path[i+1].Node);

    if path[i].Typ <> EGraphNode.NORMAL then
    begin
      j := Random(1, 4);
      Self._Path += path[i];
    end
    else
      j := 0;

    while j < High(line) do
    begin
      Self._Path += TGraphNode.Create(line[j]);

      if smallSteps then
        Inc(j, Random(1, 4))
      else
        Inc(j, Random(3, 12));
    end;
  end;

  Self._Path += path.Last;

  if Self.AdaptiveWalk then
  begin
    Self.AdaptiveToggleDistances := Self.AdaptiveDistance.Offset(Random(-6,6), Random(-16,16));
    Self.AdaptiveWalkCheck(me);
  end;
end;

function TRSWalker._AdvancePath(out index: Integer; me: TPoint; angle: Double): Boolean;
var
  tmp: TPoint;
  previous, nearest, furthest: Integer;
begin
  Self._Node := EGraphNode.NORMAL;
  previous := index;

  nearest := Self._Path.NearestIndex(me);

  Self._Index := nearest;

  while nearest < High(Self._Path) do
  begin
    if Self._Path[nearest].Typ = EGraphNode.TELEPORT then
    begin
      index := nearest;
      Self._Node := EGraphNode.TELEPORT;
      Exit(nearest > previous);
    end;

    if Self.IsWalkable(Self._Path[nearest+1].Node, me, tmp, angle) then
      Break;
    Inc(nearest);
  end;

  furthest := nearest;
  if Self._Path[furthest].Typ = EGraphNode.NORMAL then
  begin
    while furthest < High(Self._Path) do
    begin
      if Self._Path[furthest].Typ = EGraphNode.TELEPORT then
      begin
        index := furthest;
        Self._Node := EGraphNode.TELEPORT;
        Exit(nearest > previous);
      end;

      if Self._Path[furthest+1].Typ = EGraphNode.TELEPORT then
      begin
        index := furthest+1;
        Self._Node := EGraphNode.TELEPORT;
        Exit(nearest > previous);
      end;

      if not Self.IsWalkable(Self._Path[furthest+1].Node, me, tmp, angle) then
        Break;

      if (Self._Path[Inc(furthest)].Typ <> EGraphNode.NORMAL) then
      begin
        Self._Node := Self._Path[furthest].Typ;
        Break;
      end;
    end;
  end
  else
    Self._Node := Self._Path[furthest].Typ;

  index := furthest;

  Result := index > previous;

  if Result and Biometrics.RandomBoolean(0.002) then
    index := Random(nearest, furthest);
end;

function TRSWalker.GetNextStep(out index: Integer; out radians: Double; me: TPoint; fails: Integer; debug: Boolean): Integer;
begin
  if debug then
    Self.DebugPath(index, me);

  if index = High(Self._Path) then
    Exit(0);

  if Self._AdvancePath(index, me, radians) then
    Exit(0);

  Result := fails;

  //Likely haven't moved far enough to advance to next point
  if Inc(Result) < 5 then
  begin
    Sleep(300);
    Exit;
  end;

  //Screen walking struggles, so disable it
  if Self.AdaptiveWalk and Self.ScreenWalk then
  begin
    Self.ScreenWalk := False;
    if Self._AdvancePath(index, me, radians) then
      Exit(0);
  end;

  if (Result = 5) then
  begin
    Minimap.CompassRadians := radians + RandomLeft(PI/6, TAU) * Random(-1,1);
    radians := Minimap.CompassRadians;
  end;

  if Result mod 2 = 0 then
    Minimap.WaitFlag();
end;


(*
## TRSWalker.WalkPath
```pascal
function TRSWalker.WalkPath(Path: TPointArray; minDist: Integer = 0): Boolean;
```
Walks a path of points taken from the loaded map. We advice that minDist is not 0.

Parameters:
- Path
	Array of points taken from the loaded map to walk. Must be ordered from start to finish.
- minDist
	Determines when the method returns once the final point has been clicked. Default value: 0.
	| *minDist=0* waits until the player has reached the final point.
	| *minDist=20* waits until the player is within 20 pixels of the final point.

Example:
```pascal
Walker.WalkPath([[100,100],[120,120],[140,140],[160,160],[180,180]]);
```
*)
function TRSWalker.WalkPath(path: TGraphNodeArray; minDist: Integer = 0; debug: Boolean = False): Boolean;
var
  me: TPoint;
  idx, fails: Integer;
  radians: Double;
begin
  Self._WalkPathSetup(path);

  radians := Minimap.CompassRadians;
  minDist := Min(minDist, Max(minDist, 3));

  while Self.Walking and (fails < 10) do
  begin
    me := Self.Position();

    fails := Self.GetNextStep(idx, radians, me, fails, debug);
    if fails > 0 then
      Continue;

    case Self._Node of
      EGraphNode.NORMAL: if Self.WalkStep(me, idx, minDist) and (idx = High(Self._Path)) then Exit(True);
      EGraphNode.DOOR: Self.CrossDoor(me, idx);
      EGraphNode.STAIRS: Self.UseStairs(me, idx);
      EGraphNode.OBSTACLE, EGraphNode.SHORTCUT, EGraphNode.TRANSPORT,
      EGraphNode.TELEPORT: Self.UseNodeCallback(idx);
      EGraphNode.FAIRYRING: Self.UseFairyRing(me, idx);
    end;
  end;

  if fails = 10 then
    WriteLn GetDebugLn(Self.Name, 'Failed to advance path', ELogLevel.WARN);
end;

(*
## TRSWalker.WalkBlind
```pascal
function TRSWalker.WalkBlind(Destination: TPoint; minDist: Integer = 0): Boolean;
```
"Blindly" walks to a point taken from the loaded map.
A straight line is generated between the player's position and destination which is then walked.

Parameters:
- Destination
  Destination point taken from the loaded map.
- minDist
	Determines when the method returns once the final point has been clicked. Default value: 0.
	| *minDist=0* waits until the player has reached the final point.
	| *minDist=20* waits until the player is within 20 pixels of the final point.

Example:
```pascal
Walker.WalkBlind([300, 300]);
```
*)
function TRSWalker.WalkBlind(destination: TPoint; minDist: Integer = 0): Boolean;
begin
  Result := Self.WalkPath([TGraphNode.Create(destination)], minDist);
end;


(*
## TRSWalker.GetClosestPoint
```pascal
function TRSWalker.GetClosestPoint(me: TPoint; destinations: TPointArray; out path: TGraphNodeArray): TPoint;
```
Method used to get the closest `destination` point to `me`.
*)
function TRSWalker.GetClosestPoint(me: TPoint; destinations: TPointArray; out path: TGraphNodeArray): TPoint;
var
  shortPaths: array of TGraphNodeArray;
  best, dist, i: Integer;
  destination: TPoint;
  pathDist: Double;
begin
  best := $FFFFFF;

  for destination in destinations do
  begin
    if not me.InRange(destination, best) then
      Continue;

    try
      path := Self.WebGraph^.PathBetween(me, destination, 0, 4);
    except
      Continue;
    end;

    if path = [] then
      Continue;

    pathDist := 0;
    for i := 0 to High(path)-1 do
    begin
      pathDist += path[i].Node.DistanceTo(path[i+1].Node);
      if pathDist > best then
        Continue(2);
    end;

    dist := Floor(pathDist);

    if dist < best then
    begin
      shortPaths := [path];
      best := dist;
    end
    else if dist = best then
      shortPaths += path;

    path := [];
  end;

  if shortPaths = [] then
    Exit(destinations.NearestPoint(me));

  path := shortPaths.Random();
  Result := path.Last.Node;
end;


function TRSWalker.GetPath(me, destination: TPoint; randomness: Double): TGraphNodeArray;
begin
  Result := Self.WebGraph^.PathBetween(me, destination, randomness, 4);
end;

(*
## TRSWalker.WebWalk
```pascal
function TRSWalker.WebWalkEx(me, destination: TPoint; minDist: Integer = 0; randomness: Double = 0): Boolean;
function TRSWalker.WebWalk(destination: TPoint; minDist: Integer = 0; randomness: Double = 0): Boolean;
function TRSWalker.WebWalk(destinations: TPointArray; minDist: Integer = 0; randomness: Double = 0): Boolean; overload;
```
Web walks to the destination point on the loaded map. Does **not** handle any obstacles.
*)
function TRSWalker.WebWalkEx(me, destination: TPoint; minDist: Integer = 0; randomness: Double = 0; debug: Boolean = False): Boolean;
var
  path: TGraphNodeArray;
begin
  if not System.InRange(randomness, 0, 1) then
    raise GetDebugLn(Self.Name, 'WebWalk `randomness` must be between 0.0 an 1.0');

  if me.InRange(destination, 3) then
    Exit(True);
  path := Self.GetPath(me, destination, randomness);
  Result := Self.WalkPath(path, minDist, debug);
end;

function TRSWalker.WebWalk(destination: TPoint; minDist: Integer = 0; randomness: Double = 0; debug: Boolean = False): Boolean;
begin
  Result := Self.WebWalkEx(Self.Position(), destination, minDist, randomness, debug);
end;

function TRSWalker.WebWalk(destinations: TPointArray; minDist: Integer = 0; randomness: Double = 0; debug: Boolean = False): Boolean; overload;
var
  me, destination: TPoint;
  path: TGraphNodeArray;
begin
  if not System.InRange(randomness, 0, 1) then
    raise GetDebugLn(Self.Name, 'WebWalk `randomness` must be between 0.0 an 1.0');

  me := Self.Position();
  destination := Self.GetClosestPoint(me, destinations, path);

  if me.InRange(destination, 3) then
    Exit(True);

  Result := Self.WalkPath(path, minDist, debug);
end;

(*
## TRSWalker.MakePointVisible
```pascal
function TRSWalker.MakePointVisible(p: TPoint): Boolean;
function TRSWalker.MakePointVisible(tpa: TPointArray): Boolean; overload;
```
Wrapper function used to attempt to make a Point visible on the MainScreen.
*)
function TRSWalker.MakePointVisible(me: TPoint; pt: TPoint): Boolean;
begin
  Result := Minimap.MakePointVisible(Self.Point2MM(me, pt, Minimap.CompassRadians));
end;

function TRSWalker.MakePointVisible(pt: TPoint): Boolean; overload;
begin
  Result := Self.MakePointVisible(Self.Position(), pt);
end;
