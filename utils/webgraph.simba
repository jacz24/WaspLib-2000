(*
# WebGraph
Responsible for handling webwalking or any other graph logic you may need.

It's partially based on the original webgraph logic by [slacky](https://slacky.one/)
but it was written from scratch by Torwent.
*)

{$DEFINE WL_WEBGRAPH_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}

{$R-}

{$IFDEF RANGECHECKS}
begin
  WriteLn GetDebugLn('WebGraph', 'Range checks are enabled for webgraphs, these should be disabled in production!', ELogLevel.WARN);
end;
{$ENDIF}

type
(*
## EGraphNode
```pascal
EGraphNode = enum(
  NORMAL, DOOR, STAIRS, SHORTCUT, OBSTACLE, TRANSPORT, TELEPORT, FAIRYRING,
  BLOCKED
);
```
Enum representing the type of nodes in a `TWebGraph`.
*)
  EGraphNode = enum(
    NORMAL, DOOR, STAIRS, SHORTCUT, OBSTACLE, TRANSPORT, TELEPORT, FAIRYRING,
    BLOCKED
  );

  TGraphNodeFunction = function (): Boolean  of object;

  TGraphNode = record
    Node: TPoint;
    Typ: EGraphNode;
    Check, Handle: TGraphNodeFunction;
  end;

function TGraphNode.Create(pt: TPoint; typ: EGraphNode = EGraphNode.NORMAL; check, handle: TGraphNodeFunction = nil): TGraphNode; static;
begin
  Result.Node := pt;
  Result.Typ := typ;
  Result.Check := @check;
  Result.Handle := @handle;
end;

type
  TGraphNodeArray = array of TGraphNode;

function TGraphNodeArray.Offset(pt: TPoint): TGraphNodeArray;
var
  i: Integer;
begin
  for i := 0 to High(Self) do
    Result += [Self[i].Node.Offset(pt), Self[i].Typ];
end;

function TGraphNodeArray.IndexOf(value: TPoint): Integer; overload;
begin
  for Result := 0 to High(Self) do
    if Self[Result].Node = value then
      Exit;
  Result := -1;
end;

function TGraphNodeArray.NearestIndex(pt: TPoint): Integer;
var
  i: Integer;
  dist, best: Double;
begin
  best := $FFFFFF;
  for i := 1 to High(Self) do
  begin
    dist := Self[i].Node.DistanceTo(pt);

    if (dist < best) then
    begin
      best := dist;
      Result := i;
    end;
  end;
end;

function TGraphNodeArray.PolylineLength(): Double;
var
  i: Integer;
begin
  if Length(Self) < 2 then Exit;
  for i := 0 to High(Self)-1 do
    Result += Self[i].Node.DistanceTo(Self[i+1].Node);
end;

type
  TWebGraph = record
    Nodes: TGraphNodeArray;
    Paths: T2DIntegerArray;

    WalkableSpace: TPointArray;
    WalkableClusters, ObjectClusters: T2DPointArray;
    Tree: TKDPointTree;
  end;

  PWebGraph = ^TWebGraph;

procedure TWebGraph.Setup();
var
  tpa: TPointArray;
  node: TGraphNode;
begin
  for node in Self.Nodes do
    tpa += node.Node;
  Self.Tree := TKDPointTree.Create(tpa);
end;

function TWebGraph.Copy(): TWebGraph;
begin
  Result.Nodes := System.Copy(Self.Nodes);
  Result.WalkableSpace := System.Copy(Self.WalkableSpace);
  Result.WalkableClusters := System.Copy(Self.WalkableClusters);
  Result.ObjectClusters := System.Copy(Self.ObjectClusters);
  Result.Setup();
end;

procedure TWebGraph.BlockArea(area: TBox; inside: Boolean = True);
var
  i: Integer;
begin
  if inside then
  begin
    for i := 0 to High(Self.Nodes) do
      if area.Contains(Self.Nodes[i].Node) then
        Self.Nodes[i].Typ := EGraphNode.BLOCKED;
    Exit;
  end;

  for i := 0 to High(Self.Nodes) do
    if not area.Contains(Self.Nodes[i].Node) then
      Self.Nodes[i].Typ := EGraphNode.BLOCKED;
end;


function TWebGraph.NearNodesIndices(pt: TPoint; amount: Integer): TIntegerArray;
var
  i, n: Integer;
  weights: TDoubleArray;
  tpa: TPointArray;
begin
  tpa := Self.Tree.KNearest(pt, amount);

  for i := 0 to High(tpa) do
    if Self.WalkableClusters.InSameTPA(pt, tpa[i]) then
    begin
      n := Self.Nodes.IndexOf(tpa[i]);
      if n = -1 then Continue;
      Result += n;
      weights += pt.DistanceTo(tpa[i]);
    end;

  if Result = [] then
    for i := 0 to High(tpa) do
    begin
      n := Self.Nodes.IndexOf(tpa[i]);
      if n = -1 then Continue;
      Result += n;
      weights += pt.DistanceTo(tpa[i]);
    end;

  Result.Sort(weights, True);
end;


function TWebGraph.FindPath(start, finish: Integer; rnd: Double = 0): TIntegerArray;
type TNode = record Indices: TIntegerArray; Score: Double; end;
var queue: array of TNode;

  function GetNextShortest(): TNode;
  var
    i, node: Integer;
  begin
    Result := queue[0];
    for i := 1 to High(queue) do
      if queue[i].Score < Result.Score then
      begin
        node   := i;
        Result := queue[i];
      end;
    Delete(queue, node, 1);
  end;

var
  visited, checked: TBooleanArray;
  cIdx, pathIdx, i: Integer;
  current, node: TNode;
  p, q: TPoint;
  hyp: Double;
begin
  queue   := [[[start],0]];
  SetLength(visited, Length(Self.Nodes));
  SetLength(checked, Length(Self.Nodes));

  for i := 0 to High(Self.Nodes) do
    visited[i] := Self.Nodes[i].Typ = EGraphNode.BLOCKED;

  while Length(queue) <> 0 do
  begin
    current := GetNextShortest();
    cIdx := current.Indices[High(current.Indices)];

    if visited[cIdx] then
      Continue;

    visited[cIdx] := True;

    if cIdx = finish then
      Exit(current.Indices);

    p := Self.Nodes[cIdx].Node;

    for pathIdx in Self.Paths[cIdx] do
    begin
      if visited[pathIdx] then
        Continue;

      q := Self.Nodes[pathIdx].Node;
      node.Indices := current.Indices + pathIdx;

      hyp := Hypot(p.X-q.X, p.Y-q.Y);

      if @Self.Nodes[pathIdx].Check = nil then
      begin
        case Self.Nodes[pathIdx].Typ of
          EGraphNode.NORMAL: node.Score := current.Score + hyp + (hyp*Random()*rnd-rnd/2) + 1;
          EGraphNode.DOOR:   node.Score := current.Score + hyp + (hyp*Random()*rnd-rnd/2) + 10;
          else node.Score := current.Score + hyp + (hyp*Random()*rnd-rnd/2) + 100;
        end;
        queue += node;
        Continue;
      end;

      if checked[pathIdx] or Self.Nodes[pathIdx].Check() then
      begin
        checked[pathIdx] := True;
        case Self.Nodes[pathIdx].Typ of
          EGraphNode.DOOR: node.Score := current.Score + hyp + (hyp*Random()*rnd-rnd/2) + 10;
          EGraphNode.TELEPORT, EGraphNode.FAIRYRING: node.Score := current.Score + hyp*0.8 + 5;
          else node.Score := current.Score + hyp + (hyp*Random()*rnd-rnd/2) + 10;
        end;
        queue += node;
        Continue;
      end;

      visited[pathIdx] := True;
    end;
  end;
end;


function TWebGraph.PathBetween(a, b: TPoint; rnd: Double = 0; attempts: Integer = 3): TGraphNodeArray;
var
  nodeA, nodeB: TGraphNode;
  i, j: Integer;
  nS, nG, indices: TIntegerArray;
begin
  nS := Self.NearNodesIndices(a, attempts);
  nG := Self.NearNodesIndices(b, attempts);

  nodeA := [a, EGraphNode.NORMAL];
  nodeB := [b, EGraphNode.NORMAL];

  if nS[0] = nG[0] then
    Exit([nodeA, nodeB]);

  if (Length(nG) = 1) and (Self.Paths[nG[0]] = []) then
    raise GetDebugLn('WebGraph', 'Points ' + ToStr(a) + ' and ' + ToStr(b) + ' don''t connect! No paths available.');

  for i := 0 to High(nS) do
  begin
    if nS[i] = -1 then
      Continue;
    for j := 0 to High(nG) do
    begin
      if nG[j] = -1 then
        Continue;
      if nS[i] = nG[j] then Continue;

      indices := Self.FindPath(nS[i],nG[j], rnd);
      if Length(indices) > 0 then
        Break(2);
    end;
  end;

  if Length(indices) = 0 then
    raise GetDebugLn('WebGraph', 'Points ' + ToStr(a) + ' and ' + ToStr(b) + ' don''t connect!');

  Result += nodeA;
  for i in indices do
    Result += Self.Nodes[i];
  Result += nodeB;
end;


function TWebGraph.PathToNear(a: TPoint; out b: TPoint; rnd: Double = 0): TGraphNodeArray;
var
  i: Integer;
  cluster: TPointArray;
  best: TIntegerArray;
begin
  for i := 0 to High(Self.WalkableClusters) do
    if Self.WalkableClusters[i].Contains(a) then
    begin
      cluster := Self.WalkableClusters[i];
      Break;
    end;

  if cluster = [] then
    raise GetDebugLn('WebGraph', 'Can''t find player cluster containg: ' + ToStr(a));

  best := Self.NearNodesIndices(b, 12);
  for i := 0 to High(best) do
  begin
    b := Self.Nodes[best[i]].Node;
    if cluster.Contains(b) then
      Exit(Self.PathBetween(a, b, rnd, 2));
  end;
end;


function TWebGraph.AddNode(pt: TPoint; typ: EGraphNode; fromNode: Integer): Boolean;
var
  i: Integer;
begin
  if fromNode < 0 then
    Exit(False);

  i := Length(Self.Nodes);
  SetLength(Self.Nodes, i+1);
  SetLength(Self.Paths, i+1);
  Self.Nodes[i] := [pt, typ, nil];

  Self.Paths[fromNode] += i;
  Self.Paths[i] += fromNode;
  Result := True;
end;


procedure TWebGraph.ConnectNodes(a,b: Integer);
begin
  if not Self.Paths[a].Contains(b) then
    Self.Paths[a] += b;
  if not Self.Paths[b].Contains(a) then
    Self.Paths[b] += a;
end;

procedure TWebGraph.ConnectNodes(a,b: TPoint); overload;
var
  i, idxA, idxB: Integer;
begin
  idxA := -1;
  idxB := -1;

  for i := 0 to High(Self.Nodes) do
  begin
    if Self.Nodes[i].Node = a then
    begin
      idxA := i;
      if idxB > -1 then Break;
    end;
    if Self.Nodes[i].Node = b then
    begin
      idxB := i;
      if idxA > -1 then Break;
    end;
  end;

  Self.ConnectNodes(idxA,idxB);
end;

procedure TWebGraph.ConnectNodes(a: Integer; b: TPoint); overload;
var
  i: Integer;
begin
  i := Self.Nodes.IndexOf(b);
  if i = -1 then Exit;

  Self.ConnectNodes(a, i);
end;

procedure TWebGraph.ConnectNodesEx(a,b: TPoint);
var
  p, q: TPoint;
begin
  p := Self.Tree.Nearest(a, False);
  q := Self.Tree.Nearest(b, False);
  Self.ConnectNodes(p,q);
end;


function TWebGraph.DeleteNode(node: Integer): Integer;
var
  i,j,n,curr: Integer;
  marked: TIntegerArray;
begin
  marked += node;
  repeat
    curr := marked.Pop;

    for n in Self.Paths[curr] do
    begin
      Self.Paths[n].Remove(curr);
      if Self.Paths[n] = [] then
        marked += n;
    end;

    // offset remainding nodes
    for i:=0 to High(Self.Paths) do
      for j:=0 to High(Self.Paths[i]) do
        if Self.Paths[i][j] > curr then
          Dec(Self.Paths[i][j]);

    for i:=0 to High(marked) do
      if marked[i] > curr then Dec(marked[i]);

    // remove the node itself
    Delete(Self.Paths, curr, 1);
    Delete(Self.Nodes, curr, 1);
    Result += 1;
  until Length(marked) = 0;
end;

procedure TWebGraph.DeleteNodes(b: TBox);
var
  i: Integer;
begin
  for i := High(Self.Nodes) downto 0 do
    if b.Contains(Self.Nodes[i].Node) then
      Self.DeleteNode(i);
end;


procedure TWebGraph.AddLink(a, b: TPoint; typ: EGraphNode; handle: TGraphNodeFunction);
var
  i, j, n: Integer;
  tpa: TPointArray;
begin
  i := Length(Self.Nodes);
  SetLength(Self.Nodes, i+2);
  SetLength(Self.Paths, i+2);

  Self.Nodes[i]   := TGraphNode.Create(a, typ, @handle);
  Self.Nodes[i+1] := TGraphNode.Create(b, typ, @handle);
  Self.ConnectNodes(i, i+1);

  tpa := Self.Tree.KNearest(a, 8);
  for j := 0 to High(tpa) do
  begin
    if tpa[j] = b then Continue;
    if not Self.WalkableClusters.InSameTPA(a, tpa[j]) then Continue;

    n := Self.Nodes.IndexOf(tpa[j]);
    if n = -1 then Continue;
    Self.Paths[i] += n;
    Self.Paths[n] += i;
  end;

  tpa := Self.Tree.KNearest(b, 8);
  for j := 0 to High(tpa) do
  begin
    if tpa[j] = a then Continue;
    if not Self.WalkableClusters.InSameTPA(b, tpa[j]) then Continue;

    n := Self.Nodes.IndexOf(tpa[j]);
    if n = -1 then Continue;
    Self.Paths[i+1] += n;
    Self.Paths[n] += i+1;
  end;
end;

procedure TWebGraph.AddLink(a, b: TPoint; typ: EGraphNode; handleA, handleB: TGraphNodeFunction); overload;
var
  i, j, n: Integer;
  tpa: TPointArray;
begin
  i := Length(Self.Nodes);
  SetLength(Self.Nodes, i+2);
  SetLength(Self.Paths, i+2);

  Self.Nodes[i]   := TGraphNode.Create(a, typ, @handleA);
  Self.Nodes[i+1] := TGraphNode.Create(b, typ, @handleB);
  Self.ConnectNodes(i, i+1);

  tpa := Self.Tree.KNearest(a, 8);
  for j := 0 to High(tpa) do
  begin
    if tpa[j] = b then Continue;
    if not Self.WalkableClusters.InSameTPA(a, tpa[j]) then Continue;

    n := Self.Nodes.IndexOf(tpa[j]);
    if n = -1 then Continue;
    Self.Paths[i] += n;
    Self.Paths[n] += i;
  end;

  tpa := Self.Tree.KNearest(b, 8);
  for j := 0 to High(tpa) do
  begin
    if tpa[j] = a then Continue;
    if not Self.WalkableClusters.InSameTPA(b, tpa[j]) then Continue;

    n := Self.Nodes.IndexOf(tpa[j]);
    if n = -1 then Continue;
    Self.Paths[i+1] += n;
    Self.Paths[n] += i+1;
  end;
end;

procedure TWebGraph.AddLink(pt, a, b: TPoint; typ: EGraphNode; handle: TGraphNodeFunction); overload;
var
  i, j, n: Integer;
  tpa: TPointArray;
begin
  i := Length(Self.Nodes);
  SetLength(Self.Nodes, i+1);
  SetLength(Self.Paths, i+1);

  tpa := Self.Tree.KNearest(b, 8);
  for j := 0 to High(tpa) do
  begin
    if tpa[j] = b then Continue;
    if not Self.WalkableClusters.InSameTPA(a, tpa[j]) then Continue;

    n := Self.Nodes.IndexOf(tpa[j]);
    if n = -1 then Continue;
    Self.Paths[i] += n;
    Self.Paths[n] += i;
  end;

  tpa := Self.Tree.KNearest(b, 8);
  for j := 0 to High(tpa) do
  begin
    if tpa[j] = a then Continue;
    if not Self.WalkableClusters.InSameTPA(b, tpa[j]) then Continue;

    n := Self.Nodes.IndexOf(tpa[j]);
    if n = -1 then Continue;
    Self.Paths[i] += n;
    Self.Paths[n] += i;
  end;

  Self.Nodes[i] := TGraphNode.Create(pt, typ, @handle);
end;

procedure TWebGraph.AddTeleport(pt: TPoint; check, handle: TGraphNodeFunction);
var
  i, j, n: Integer;
  tpa: TPointArray;
begin
  i := Length(Self.Nodes);
  Self.Nodes += TGraphNode.Create(pt, EGraphNode.TELEPORT, @check, @handle);
  SetLength(Self.Paths, Length(Self.Nodes));

  tpa := Self.Tree.KNearest(pt, 12);
  for j := 0 to High(tpa) do
  begin
    if not Self.WalkableClusters.InSameTPA(pt, tpa[j]) then
      Continue;

    n := Self.Nodes.IndexOf(tpa[j]);
    if n = -1 then Continue;
    Self.Paths[i] += n;
    Self.Paths[n] += i;
  end;

  for j := 0 to High(Self.Nodes)-1 do
  begin
    if Self.Nodes[i].Node.InRange(Self.Nodes[j].Node, 120) then
      Continue;
    Self.Paths[j] += i;
  end;
end;

procedure TWebGraph.AddFairyRing(pt: TPoint);
var
  i, j, n: Integer;
  tpa: TPointArray;
begin
  i := Length(Self.Nodes);
  Self.Nodes += TGraphNode.Create(pt, EGraphNode.FAIRYRING, nil);
  SetLength(Self.Paths, Length(Self.Nodes));

  tpa := Self.Tree.KNearest(pt, 8);
  for j := 0 to High(tpa) do
  begin
    if not Self.WalkableClusters.InSameTPA(pt, tpa[j]) then
      Continue;

    n := Self.Nodes.IndexOf(tpa[j]);
    if n = -1 then Continue;
    Self.Paths[i] += n;
    Self.Paths[n] += i;
  end;

  for j := 0 to High(Self.Nodes) do
    if Self.Nodes[j].Typ = EGraphNode.FAIRYRING then
    begin
      Self.Paths[j] += i;
      Self.Paths[i] += j;
    end;
end;


procedure TWebGraph._MergeAdjacentClusters();
var
  i, j, k: Integer;
  merged: Boolean;
  boundsA, boundsB, overlapBox: TBox;
  borderA, borderB: TPointArray;
  matrix: TBooleanMatrix;
  pt: TPoint;
  matrixW, matrixH: Integer;
begin
  //Merge walkable clusters that are adjacent or overlapping
  //This is needed when loading multiple chunks - their clusters need to be combined
  if Length(Self.WalkableClusters) < 2 then Exit;

  repeat
    merged := False;
    for i := High(Self.WalkableClusters) downto 1 do
    begin
      if Self.WalkableClusters[i] = [] then Continue;
      boundsA := Self.WalkableClusters[i].Bounds();

      for j := i - 1 downto 0 do
      begin
        if Self.WalkableClusters[j] = [] then Continue;
        boundsB := Self.WalkableClusters[j].Bounds();

        //Quick bounds check - if boxes don't overlap when expanded by 2, clusters aren't adjacent
        if not boundsA.Expand(2).Overlap(boundsB) then Continue;

        //Get the overlap region
        overlapBox := [
          Max(boundsA.X1, boundsB.X1) - 2,
          Max(boundsA.Y1, boundsB.Y1) - 2,
          Min(boundsA.X2, boundsB.X2) + 2,
          Min(boundsA.Y2, boundsB.Y2) + 2
        ];

        //Skip if overlap box is invalid or too large (sanity check)
        matrixW := overlapBox.Width + 1;
        matrixH := overlapBox.Height + 1;
        if (matrixW <= 0) or (matrixH <= 0) or (matrixW > 10000) or (matrixH > 10000) then
          Continue;

        //Extract points from both clusters in the overlap region
        borderA := Self.WalkableClusters[i].ExtractBox(overlapBox);
        borderB := Self.WalkableClusters[j].ExtractBox(overlapBox);

        if (borderA = []) or (borderB = []) then Continue;

        //Build a matrix for O(1) lookups of cluster j's border points
        SetLength(matrix, matrixH, matrixW);
        for pt in borderB do
          if overlapBox.Contains(pt) then
            matrix[pt.Y - overlapBox.Y1, pt.X - overlapBox.X1] := True;

        //Check if any point from cluster i is adjacent to cluster j
        for k := 0 to High(borderA) do
        begin
          pt := borderA[k];
          if not overlapBox.Contains(pt) then Continue;

          //Check the point and its 4 neighbors
          if matrix[pt.Y - overlapBox.Y1, pt.X - overlapBox.X1] or
             ((pt.X + 1 <= overlapBox.X2) and matrix[pt.Y - overlapBox.Y1, pt.X + 1 - overlapBox.X1]) or
             ((pt.X - 1 >= overlapBox.X1) and matrix[pt.Y - overlapBox.Y1, pt.X - 1 - overlapBox.X1]) or
             ((pt.Y + 1 <= overlapBox.Y2) and matrix[pt.Y + 1 - overlapBox.Y1, pt.X - overlapBox.X1]) or
             ((pt.Y - 1 >= overlapBox.Y1) and matrix[pt.Y - 1 - overlapBox.Y1, pt.X - overlapBox.X1]) then
          begin
            //Merge cluster i into cluster j
            Self.WalkableClusters[j] += Self.WalkableClusters[i];
            Delete(Self.WalkableClusters, i, 1);
            merged := True;
            Break(2);
          end;
        end;
      end;
    end;
  until not merged;
end;

procedure TWebGraph._ConnectBoundaryNodes(existingCount: Integer);
var
  i, j: Integer;
  dist: Double;
  maxDist: Double;
begin
  //Connect nodes from the newly added graph to existing nodes if they're close
  //This bridges gaps between chunks at their boundaries
  maxDist := 40;  //Maximum distance to auto-connect nodes (about 2 tiles)

  for i := existingCount to High(Self.Nodes) do
  begin
    if Self.Nodes[i].Typ = EGraphNode.BLOCKED then Continue;

    for j := 0 to existingCount - 1 do
    begin
      if Self.Nodes[j].Typ = EGraphNode.BLOCKED then Continue;

      dist := Self.Nodes[i].Node.DistanceTo(Self.Nodes[j].Node);
      if dist > maxDist then Continue;

      //Check if they're in the same walkable cluster
      if not Self.WalkableClusters.InSameTPA(Self.Nodes[i].Node, Self.Nodes[j].Node) then
        Continue;

      //Connect them if not already connected
      if not Self.Paths[i].Contains(j) then
        Self.Paths[i] += j;
      if not Self.Paths[j].Contains(i) then
        Self.Paths[j] += i;
    end;
  end;
end;

procedure TWebGraph.Merge(graph: TWebGraph);
var
  i, j, len: Integer;
begin
  len := Length(Self.Nodes);

  for i := 0 to High(graph.Nodes) do
  begin
    Self.Nodes += graph.Nodes[i];
    Self.Paths += graph.Paths[i];

    for j := 0 to High(Self.Paths[len+i]) do
      Self.Paths[len+i,j] += len;
  end;

  Self.WalkableSpace    += graph.WalkableSpace;
  Self.WalkableClusters += graph.WalkableClusters;
  Self.ObjectClusters   += graph.ObjectClusters;
end;

(*
## TWebGraph.FinalizeMerge
Called after all graphs have been merged to merge adjacent walkable clusters
across chunk boundaries. This should be called once after all Merge() calls
are complete.
*)
procedure TWebGraph.FinalizeMerge();
var
  t: UInt64;
begin
  t := GetTimeRunning();
  WriteLn GetDebugLn('WebGraph', 'FinalizeMerge: starting with ' + ToStr(Length(Self.WalkableClusters)) + ' clusters');
  Self._MergeAdjacentClusters();
  WriteLn GetDebugLn('WebGraph', 'FinalizeMerge: done, now ' + ToStr(Length(Self.WalkableClusters)) + ' clusters, took ' + ToStr(Round((GetTimeRunning()-t)/1000, 2)) + 's');
end;

procedure TWebGraph.Draw(img: TImage);
var
  i,j: Integer;
begin
  if Self.Nodes = [] then Exit;

  img.DrawColor := $00EAEA;
  for i := 0 to High(Self.Paths) do
    if Self.Nodes[i].Typ <> EGraphNode.TELEPORT then
      for j := 0 to High(Self.Paths[i]) do
        if Self.Nodes[Self.Paths[i, j]].Typ <> EGraphNode.TELEPORT then
          img.DrawLine(Self.Nodes[i].Node, Self.Nodes[Self.Paths[i, j]].Node);

  for i := 0 to High(Self.Nodes) do
  begin
    case Self.Nodes[i].Typ of
      EGraphNode.DOOR:  img.DrawColor := $FF105F;
      EGraphNode.TELEPORT: img.DrawColor := $FF7F00;
      EGraphNode.NORMAL: img.DrawColor := $0101CC;
      else img.DrawColor := $FF00FF;
    end;
    img.DrawBox(TBox.Create(Self.Nodes[i].Node, 1, 1));
  end;

end;

procedure TWebGraph.Draw(canvas: TImageBoxCanvas); overload;
var
  i,j: Integer;
  color: TColor;
begin
  if Self.Nodes = [] then Exit;

  for i := 0 to High(Self.Paths) do
    if Self.Nodes[i].Typ <> EGraphNode.TELEPORT then
      for j := 0 to High(Self.Paths[i]) do
        if Self.Nodes[Self.Paths[i, j]].Typ <> EGraphNode.TELEPORT then
        begin
          if Self.Paths[i, j] > High(Self.Nodes) then Continue;
          canvas.DrawLine(Self.Nodes[i].Node, Self.Nodes[Self.Paths[i, j]].Node, $00EAEA);
        end;

  for i := 0 to High(Self.Nodes) do
  begin
    case Self.Nodes[i].Typ of
      EGraphNode.DOOR: color := $FF105F;
      EGraphNode.TELEPORT: color := $FF7F00;
      EGraphNode.NORMAL: color := $0101CC;
      else color :=  $FF00FF;
    end;
    canvas.DrawBoxFilled(TBox.Create(Self.Nodes[i].Node, 1, 1), color);
  end;
end;
{$R+}

