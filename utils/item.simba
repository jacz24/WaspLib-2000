(*
# Item
Page dedicated to runescape items and misc functions related to them.
*)
{$DEFINE WL_ITEM_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}

const
(*
## Quantity Constants
```pascal
QUANTITY_ALL = 0;
QUANTITY_ALL_BUT_ONE = -1;
```
In WaspLib you have this 2 constants to use in interfaces that allows you to
specify "all" quantities of items, e.g. the {ref}`bank` interface.
*)
  QUANTITY_ALL = 0;
  QUANTITY_ALL_BUT_ONE = -1;

var
(*
## ITEM_SHADOW
```pascal
ITEM_SHADOW: TColor = $202030;
```
`TColor` of an item gray shadow. This shadow value will change between clients
(check {ref}`ERSClient`) and depending on the client certain interfaces being
open will also change it to {ref}`ITEM_SHADOW_GRAY`, e.g. the {ref}`Bank`
with Legacy or RuneLite.

Example:
```pascal
WriteLn ITEM_SHADOW; //$202030
```
*)
  ITEM_SHADOW: TColor = $202030;

(*
## ITEM_SHADOW_GRAY
```pascal
ITEM_SHADOW_GRAY: TColor = $333333;
```
`TColor` of an item gray shadow. This shadow value will change between clients
(check {ref}`ERSClient`) and depending on the client certain interfaces being
open will also change it, e.g. the {ref}`Bank` with Legacy or RuneLite.

Example:
```pascal
WriteLn ITEM_SHADOW; //$333333
```
*)
  ITEM_SHADOW_GRAY: TColor = $333333;

(*
## ITEM_BORDER
```pascal
ITEM_BORDER: TColor = $010000;
```
`TColor` of an item border. This value will change between clients
(check {ref}`ERSClient`).

Example:
```pascal
WriteLn ITEM_BORDER; //$010000
```
*)
  ITEM_BORDER: TColor = $010000;

(*
## ITEM_BORDER_WHITE
```pascal
ITEM_BORDER_WHITE: TColor = $FFFFFF;
```
`TColor` of a selected item border. This value will change between clients
(check {ref}`ERSClient`).

Example:
```pascal
WriteLn ITEM_BORDER_WHITE; //$FFFFFF
```
*)
  ITEM_BORDER_WHITE: TColor = $FFFFFF;

type
(*
## ERSItemQuantity
```pascal
ERSItemQuantity = enum(ONE, FIVE, TEN, CUSTOM, ALL);
```
General purpose item quantity enum.
*)
  ERSItemQuantity = enum(ONE, FIVE, TEN, CUSTOM, ALL);

(*
### ERSItemQuantity.Integer2Quantity
```pascal
function ERSItemQuantity.Integer2Quantity(quantity: Integer): ERSItemQuantity; static;
```
Internal helper function to convert a integer quantity into a ERSItemQuantity.

Example:
```pascal
WriteLn ERSItemQuantity.Integer2Quantity(5);
WriteLn ERSItemQuantity.Integer2Quantity(7);
```
*)
function ERSItemQuantity.Integer2Quantity(quantity: Integer): ERSItemQuantity; static;
begin
  case quantity of
    1:     Result := ERSItemQuantity.ONE;
    5:     Result := ERSItemQuantity.FIVE;
    10:    Result := ERSItemQuantity.TEN;
    0, -1: Result := ERSItemQuantity.ALL;
    else   Result := ERSItemQuantity.CUSTOM;
  end;
end;

(*
### ERSItemQuantity.String2Quantity
```pascal
function ERSItemQuantity.String2Quantity(str: String): ERSItemQuantity; static;
```
Internal helper function to convert a string quantity into a ERSItemQuantity.

Example:
```pascal
WriteLn ERSItemQuantity.String2Quantity('5');
WriteLn ERSItemQuantity.String2Quantity('7');
WriteLn ERSItemQuantity.String2Quantity('All');
```
*)
function ERSItemQuantity.String2Quantity(str: String): ERSItemQuantity; static;
begin
  case LowerCase(str) of
    '1':   Result := ERSItemQuantity.ONE;
    '5':   Result := ERSItemQuantity.FIVE;
    '10':  Result := ERSItemQuantity.TEN;
    'all': Result := ERSItemQuantity.ALL;
    else   Result := ERSItemQuantity.CUSTOM;
  end;
end;

type
(*
## ERSStack
```pascal
ERSStack = enum(YELLOW, WHITE, GREEN);
```
Enum representing the types of item stacks available.
*)
  ERSStack = enum(YELLOW, WHITE, GREEN);

(*
## ERSStack.Color
```pascal
property ERSStack.Color: TColor;
```
Returns a `TColor` of a {ref}`ERSStack`.
- `ERSStack.YELLOW` should be stacks between `0` and `99.999`.
- `ERSStack.WHITE` should be stacks between `100.000` and `9.999.999` and are
shown with a `K` representing the 3 least significant digits, e.g. `9.999.999`
would be seen as `9999K`.
- `ERSStack.GREEN` should be stacks between `100.000` and `9.999.999` and are
shown with an `M` representing the 6 least significant digits, e.g.
`999.999.999` would be seen as `999M`.

Example:
```pascal
WriteLn ERSStack.YELLOW.Color; //$00FFFF
WriteLn ERSStack.WHITE.Color;  //$FFFFFF
WriteLn ERSStack.GREEN.Color;  //$80FF00
```
*)
property ERSStack.Color: TColor;
begin
  case Self of
    ERSStack.YELLOW: Result := $00FFFF;
    ERSStack.WHITE:  Result := $FFFFFF;
    ERSStack.GREEN:  Result := $80FF00;
  end;
end;

(*
## ERSStack.Multiplier
```pascal
property ERSStack.Multiplier: Integer;
```
Returns the "multiplier" of a `ERSStack` which are:
- `ERSStack.YELLOW`: 0
- `ERSStack.WHITE`: 1000
- `ERSStack.GREEN`: 1000000

Example:
```pascal
WriteLn ERSStack.YELLOW.Multiplier;
```
*)
property ERSStack.Multiplier: Integer;
begin
  Result := Round(10 ** (3 * Ord(Self)));
end;


type
(*
## TRSItem
The main type that represents, well, a runescape item.
`TRSItem` is a type of `String` and therefore inherits all `String` methods.
*)
  TRSItem = String;
(*
## TRSItemArray
Array type of `TRSItem`.
*)
  TRSItemArray = array of TRSItem;


(*
## TRSItem.InBounds
```pascal
function TRSItem.InBounds(bounds: TBox; fadeTolerance: Single = 8.5): Boolean; static;
```
Checks if the specified `bounds` has an item in it.

Example:
```pascal
WriteLn TRSItem.InBounds(Inventory.Slots.Box(0));
```
*)
function TRSItem.InBounds(bounds: TBox; fadeTolerance: Single = 8.5): Boolean; static;
begin
  Result := Target.HasColor(ITEM_BORDER, fadeTolerance, 1, bounds) or
            Target.HasColor(ITEM_BORDER_WHITE, 0, 1, bounds);
end;


(*
## TRSItem.HasAmount
```pascal
function TRSItem.HasAmount(): Boolean;
```
Checks if the `TRSItem` has "doses" or "charges".

Example:
```pascal
item := 'Amulet of glory(6)';
WriteLn item.HasAmount(); //true
```
*)
function TRSItem.HasAmount(): Boolean;
begin
  Result := Self.EndsWith(')', True);
end;

(*
## TRSItem.Spread
```pascal
function TRSItem.Spread(): TRSItemArray;
```
Checks if the `TRSItem` has `(a..b)` in it's name and will spread it into a
`TRSItemArray`.

Example:
```pascal
item := 'prayer potion(1..4)';
WriteLn item.Spread(); ['prayer potion(1)', 'prayer potion(2)', 'prayer potion(3)'. 'prayer potion(4)']
item := 'prayer potion(2..1)';
WriteLn item.Spread(); ['prayer potion(2)', 'prayer potion(1)']
```
*)
function TRSItem.Spread(): TRSItemArray;
var
  parts: TStringArray;
  first, last, i: Integer;
  name: String;
begin
  parts := Self.Split('..');
  if Length(parts) <= 1 then
    Exit([Self]);

  first := StrToInt(parts[0].Last);
  last :=  StrToInt(parts[1].First);
  name := parts[0].CopyRange(1, parts[0].Length-1);

  if first < last then
  begin
    for i := first to last do
      Result += name + ToStr(i) + ')';
    Exit;
  end;

  for i := first downto last do
    Result += name + ToStr(i) + ')';
end;

(*
## TRSItem.SimplifyName
```pascal
function TRSItem.SimplifyName(): String;
```
Internal helper function to get a human like short item name, usually to search.

Example:
```pascal
item := 'Amulet of glory(6)';
WriteLn item.SimplifyName();
```
*)
function TRSItem.SimplifyName(): String;
var
  short, long: Integer;
begin
  if Self.Contains(' of ') then
    Result := Self.After(' of ').ToLower()
  else
    Result := Self.ToLower();

  if Result.EndsWith(')') then Result := Result.Before('(');

  long := Length(Result);
  short := Min(0, long - Ceil(long/3));
  Result := Result.CopyRange(0, Random(short, long));
end;

(*
## Item.StackBox
```pascal
property TRSItem.StackBox(slot: TBox): TBox; static;
```
Returns the correct text box of an item's amount text based on the item box.
*)
property TRSItem.StackBox(slot: TBox): TBox; static;
begin
  Result := [slot.X1, slot.Y1-1, slot.X1 + 35, slot.Y1 + 11];
end;


(*
## TRSItem.ReadStack
```pascal
function TRSItem.ReadStack(slot: TBox): Integer; static;
```
For use with items in interfaces like bankscreen, inventory, shops and so on to
get the number of stacked items.
*)
function TRSItem.ReadStack(slot: TBox): Integer; static;
var
  stack: ERSStack;
  color: TColor;
begin
  slot := TRSItem.StackBox[slot];

  for stack := Low(ERSStack) to High(ERSStack) do
  begin
    color := stack.Color;
    if Target.HasColor(color, 1, 1, slot) then
      Exit(OCR.RecognizeNumber(slot, RSFonts.PLAIN_11, [color], 1) * stack.Multiplier);
  end;

  if TRSItem.InBounds(slot, 0) then
    Exit;

  Result := -1;
end;

type
(*
## TRSBankItem
Helper type to handle bank items better.
This holds information about the item name, quantity and whether it's noted or
not.
*)
  TRSBankItem = object
    Item: TRSItem;
    Quantity: Integer;
    Noted: Boolean;
  end;

(*
## TRSBankItemArray
Array type of `TRSBankItem`.
*)
  TRSBankItemArray = array of TRSBankItem;

(*
## TRSBankItem.Construct
```pascal
function TRSBankItem.Construct(item: TRSItem; quantity: Integer = QUANTITY_ALL_BUT_ONE): TRSBankItem; static;
```
Creates a TRSBankItem.

Example:
```pascal
var
  bankitem: TRSBankItem;
begin
  bankitem := new TRSBankItem('abyssal whip', 1);
end.
```
*)
function TRSBankItem.Construct(item: TRSItem; quantity: Integer = QUANTITY_ALL_BUT_ONE): TRSBankItem; static;
begin
  Result := item.ToBankItem(quantity);
end;

(*
## TRSItem.ToBankItem
```pascal
function TRSItem.ToBankItem(quantity: Integer = QUANTITY_ALL_BUT_ONE): TRSBankItem;
```
Returns a `TRSBankItem` based on the `TRSItem` in question with the specified
`quantity`.

Example:
```pascal
item := 'Amulet of glory(6)';
WriteLn item.ToBankItem();
```
*)
function TRSItem.ToBankItem(quantity: Integer = QUANTITY_ALL_BUT_ONE): TRSBankItem;
begin
  Result.Quantity := quantity;
  Result.Noted := Self.StartsWith('Noted ', False);
  if Result.Noted then Result.Item := Self.After('Noted ')
  else Result.Item := Self;
end;

(*
## TRSBankItem.ToItem
```pascal
function TRSBankItem.ToItem(): TRSItem;
```
The opposite of {ref}`TRSItem.ToBankItem`
*)
function TRSBankItem.ToItem(): TRSItem;
begin
  Result := Self.Item;
  if Self.Noted then
    Result := 'noted ' + Result.ToLower();
end;
