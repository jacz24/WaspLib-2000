(*
# WebGraph Generator
This page is about webgraph generation out of collision map images.

You can force WaspLib's graph generator to always run even if there's already
cached graphs by adding the following compiler directive at the top of your
script **BEFORE INCLUDING WASPLIB**:
```pascal
{$DEFINE WL_GENERATE_GRAPH_ALWAYS}
```
*)

{$DEFINE WL_WEBGRAPHGEN_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}

{$R-}
{$IFDEF RANGECHECKS}
begin
  WriteLn GetDebugLn('WebGraphGenerator', 'Range checks are enabled for webgraph generator, these should be disabled in production!', ELogLevel.WARN);
end;
{$ENDIF}

{.$DEFINE WL_GENERATE_GRAPH_ALWAYS}

type
(*
## TWebGraphGenerator type
Record responsible for generating webgraphs from collision map images.
*)
  TWebGraphGenerator = record
    Spacing, MinimumTiles, NodeRadius, MaxConnections,
    MaxDoorConnections: Integer;
    Skeletonize: Boolean;
    Disabled: Boolean;

    WhiteClusters: T2DPointArray;
    Doors: T2DPointArray;
    Matrix: TIntegerMatrix;
  end;

function TWebGraphGenerator.Hash(): String;
var
  data: TIntegerArray;
begin
  data := [
    Self.Spacing, Self.MinimumTiles, Self.NodeRadius, Self.MaxConnections,
    Self.MaxDoorConnections, Int32(Self.Skeletonize)
  ];
  Result := HashData(EHashAlgo.CRC32, @data[0], Length(data) * SizeOf(Int32));
end;

(*
## WebGraphGenerator.Setup
```pascal
procedure TWebGraphGenerator.Setup(spacing, minimumTiles, nodeRadius, maxConnections, maxDoorConnections: Integer);
```
Sets up the `TWebGraphGenerator` with the following settings which are the
defaults:
```pascal
WebGraphGenerator.Setup(18, 4, 50, 6, 3, True);
```

Parameters explanation
- `spacing`: Lower values have better results but the generation is slower, high
values have worse results but geneartion is faster.
- `minimumTiles`: spaces with less tiles than this will be ignored.
- `nodeRadius`: closed spaces that are less than this values in pixels will have a single node in the middle.
- `maxConnections`: max connections per node.
- `maxDoorConnections`: max connections per door node.

Feel free to change the settings to suit your need and use the
{ref}`Map Debugger` to see what the results look like.

To do so you **MUST DO IT BEFORE** setting up your {ref}`Map`.
*)
procedure TWebGraphGenerator.Setup(spacing, minimumTiles, nodeRadius, maxConnections, maxDoorConnections: Integer; skeletonize: Boolean);
begin
  Self.Spacing := spacing;
  Self.MinimumTiles := minimumTiles;
  Self.NodeRadius := nodeRadius;
  Self.MaxConnections := maxConnections;
  Self.MaxDoorConnections := maxDoorConnections;
  Self.Skeletonize := skeletonize;
end;

function TWebGraphGenerator.GetDoorDirection(center: TPoint; img: TImage): TPoint;
var
  imgBounds: TBox;
  
  function SafePixelCheck(x, y: Integer): Boolean;
  begin
    Result := imgBounds.Contains([x, y]) and (img.Pixel[x, y] = $0000FF);
  end;
  
begin
  imgBounds := [0, 0, img.Width - 1, img.Height - 1];
  
  if SafePixelCheck(center.X+1, center.Y) or SafePixelCheck(center.X-1, center.Y) then
    Exit([0,1]);

  if SafePixelCheck(center.X, center.Y+1) or SafePixelCheck(center.X, center.Y-1) then
    Exit([1,0]);

  if SafePixelCheck(center.X+1, center.Y+1) or SafePixelCheck(center.X-1, center.Y-1) then
    Exit([1,-1]);

  if SafePixelCheck(center.X+1, center.Y-1) or SafePixelCheck(center.X-1, center.Y+1) then
    Exit([1,1]);

  Result := [0,0];
end;

function TWebGraphGenerator.DoorIsSeparating(center, direction: TPoint; img: TImage): Boolean;
var
  inverted: TPoint;
  i: Integer;
  splitA, splitB: Boolean;
  testPoint: TPoint;
  imgBounds: TBox;
begin
  imgBounds := [0, 0, img.Width - 1, img.Height - 1];
  inverted := direction.Rotate(HALF_PI, [0,0]);

  for i := 1 to 5 do
  begin
    testPoint := Point(center.X, center.Y) + (inverted*i);
    
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitA := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(testPoint.X - direction.X, testPoint.Y - direction.Y);
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitA := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(center.X, center.Y) + (inverted*i) + direction;
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitA := True;
          Break;
        end;
      end;
    end;
  end;

  for i := 1 to 5 do
  begin
    testPoint := Point(center.X, center.Y) - (inverted * i);
    
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitB := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(testPoint.X - direction.X, testPoint.Y - direction.Y);
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitB := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(center.X, center.Y) - (inverted * i) + direction;
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitB := True;
          Break;
        end;
      end;
    end;
  end;

  Result := splitA and splitB;
end;


function TWebGraphGenerator.FindDoors(doors: T2DPointArray; img: TImage): T2DPointArray;
var
  direction: TPoint;
  i, idx: Integer;
  imgBounds: TBox;
  centerPt, testPt1, testPt2: TPoint;
begin
  imgBounds := [0, 0, img.Width - 1, img.Height - 1];
  
  for i := 0 to High(doors) do
  begin
    case Length(doors[i]) of
      4, 8: ;
      else Continue;
    end;

    centerPt := doors[i].Mean();
    direction := Self.GetDoorDirection(centerPt, img);
    if direction = [0,0] then Continue;

    testPt1 := Point(centerPt.X + direction.X, centerPt.Y + direction.Y);
    testPt2 := Point(centerPt.X - direction.X, centerPt.Y - direction.Y);
    
    if not imgBounds.Contains(testPt1) or not imgBounds.Contains(testPt2) then
      Continue;
      
    if (img.Pixel[testPt1.X, testPt1.Y] <> $FFFFFF) or
       (img.Pixel[testPt2.X, testPt2.Y] <> $FFFFFF) then
      Continue;

    if not Self.DoorIsSeparating(centerPt, direction, img) then
      Continue;

    idx := Length(Result);
    SetLength(Result, idx+1);
    Result[idx] += centerPt;
    Result[idx] += centerPt + direction * 2;
    Result[idx] += centerPt - direction * 2;
  end;
end;


function TWebGraphGenerator.ProcessDoors(door: TPointArray; idx: Integer; out total: Integer; out mapA, mapB: TIntegerMatrix): TGraphNodeArray;
var
  a, b: Integer;
begin
  a := Self.Matrix[door[1].Y, door[1].X];
  b := Self.Matrix[door[2].Y, door[2].X];
  if a = b then Exit;

  mapA[a] += idx;
  mapB[b] += idx;

  Result := [TGraphNode.Create(door[0], EGraphNode.DOOR)];
  Self.Matrix[door[0].Y, door[0].X] := total;
  total += 1;
end;

procedure TWebGraphGenerator.ProcessSmallCluster(out graph: TWebGraph; out minRadius: Boolean; out mapA, mapB: TIntegerArray; idx, minLength: Integer; connectA, connectB: TIntegerArray);
var
  bounds: TBox;
  hi, n, j, l: Integer;
begin
  if Length(Self.WhiteClusters[idx]) < minLength then
    Exit;

  bounds := Self.WhiteClusters[idx].Bounds();

  minRadius := Max(bounds.Width, bounds.Height) >= Self.NodeRadius;
  if minRadius then
    Exit;

  graph.Nodes += TGraphNode.Create(Self.WhiteClusters[idx].Median());
  hi := High(graph.Nodes);
  SetLength(graph.Paths, hi+1);

  for n := High(mapA) downto 0 do
  begin
    j := mapA[n];
    if connectA[j] = idx then
    begin
      l := Self.Matrix[Self.Doors[j,0].Y, Self.Doors[j,0].X];
      if graph.Paths[l] <> [] then
        Delete(mapA, idx, 1);
      graph.Paths[l] += [hi];
      graph.Paths[hi] += l;
    end;
  end;

  for n := High(mapB) downto 0 do
  begin
    j := mapB[n];
    if connectB[j] = idx then
    begin
      l := Self.Matrix[Self.Doors[j,0].Y, Self.Doors[j,0].X];
      if graph.Paths[l] <> [] then
        Delete(mapB, idx, 1);
      graph.Paths[l] += [hi];
      graph.Paths[hi] += l;
    end;
  end;
end;

function TWebGraphGenerator.SplitNodes(idx: Integer): TPointArray;
var
  tpa: TPointArray;
begin
  tpa := Self.WhiteClusters[idx].Erode(1);

  if Self.Skeletonize then
    tpa := tpa.Skeleton(2, 6);

  for tpa in tpa.Partition(Self.Spacing) do
    Result += tpa.Cluster(1.5).Means();
end;

procedure TWebGraphGenerator.PreProcessCluster(constref tree: TKDPointTree; out connectMap: array of TIntegerMatrix; idx, treeIdx: Integer);
var
  p, q: TPoint;
  tpa: TPointArray;
  i: Integer;
begin
  p := tree.Data[treeIdx].Split;
  for q in tree.KNearest(p, Self.MaxConnections*2, True) do
  begin
    if Max(Abs(p.X - q.X), Abs(p.Y - q.Y)) > Self.Spacing * 2 then
      Continue;

    tpa := Self.WhiteClusters[idx].ExtractBox(TBox.Create(p, q).Expand(Self.Spacing div 2));
    tpa := tpa.AStar(p, q, False);
    if (tpa = []) or (Length(tpa) > 80) then
      Continue;

    connectMap[q.Y,q.X] += treeIdx;
    if Inc(i) > Self.MaxConnections then
      Break;
  end;
end;

procedure TWebGraphGenerator.ProcessCluster(out graph: TWebGraph; constref tree: TKDPointTree; connectMap: array of TIntegerMatrix; idx, len: Integer);
var
  p, q: TPoint;
  i, j, n: Integer;
begin
  p := tree.Data[idx].Split;
  i := idx+len;

  graph.Nodes[i] := TGraphNode.Create(p);
  Self.Matrix[p.Y, p.X] := i;

  for n in connectMap[p.Y,p.X] do
  begin
    q := tree.Data[n].Split;
    j := n+len;
    graph.Nodes[j] := TGraphNode.Create(q);
    Self.Matrix[q.Y, q.X] := j;

    if not graph.Paths[i].Contains(j) then
      graph.Paths[i] += j;
    if not graph.Paths[n].Contains(i) then
      graph.Paths[j] += i;
  end;
end;

procedure TWebGraphGenerator.ConnectLastDoors(out graph: TWebGraph; idx, door: Integer; constref tree: TKDPointTree);
var
  p, q: TPoint;
  i, j: Integer;
  cluster, tpa: TPointArray;
begin
  p := Self.Doors[door,0];
  i := Self.Matrix[p.Y, p.X];

  cluster := Self.WhiteClusters[idx] + [p];

  for q in tree.KNearest(p, Self.MaxDoorConnections, True) do
  begin
    if Max(Abs(p.X - q.X), Abs(p.Y - q.Y)) > Self.Spacing * 2 then
      Continue;

    tpa := cluster.ExtractBox(TBox.Create(p, q).Expand(Self.Spacing div 2));
    tpa := tpa.AStar(p, q, False);
    if (tpa = []) or (Length(tpa) > 80) then
      Continue;

    j := Self.Matrix[q.Y, q.X];
    graph.Paths[i] += [j];
    graph.Paths[j] += i;
  end;
end;


(*
## WebGraphGenerator.BuildGraph
```pascal
function TWebGraphGenerator._BuildGraph(map: TImage; white, red: TPointArray): TWebGraph;
function TWebGraphGenerator.BuildGraph(name: String; map: TImage): TWebGraph;
```
Magically builds a webgraph for you for a given collision map passed into `map`.

The collision map can only have 4 colors:
- white ($FFFFFF) for walkable space
- black ($000000) for non walkable space
- red ($0000FF) for doors (optional)
- gray ($333333) for objects (optional)

```{note}
This is an internal method. Don't use it if you don't know what you are doing.
```

How it works in detail is quite technical but if you want to see the result
run this example code:
```pascal
{$I WaspLib/osrs.simba}
begin
  Map.Setup([Chunk(Box(49,54,50,53), 0)]);
  Map.Debug();
end.
```

This will setup a map with a small piece of varrock and then open the
{ref}`Map Debugger`.

On the {ref}`Map Debugger` change the dropdown to the collision map if you want
to see what it looks like, that is what will go through this as the `map`
parameter and it should look something like this:

```{figure} ../../images/map_collision.png
```

As a bonus you can also see the resulting webgraph!
*)
function TWebGraphGenerator._BuildGraph(map: TImage; white, red: TPointArray): TWebGraph;
var
  i, j, n, len, minLen: Integer;
  nodes: TPointArray;
  pt: TPoint;
  tree: TKDPointTree;
  connectMap: array of TIntegerMatrix;
  doorMapA, doorMapB: TIntegerMatrix;
  connectA, connectB: TIntegerArray;
  minRadius: Boolean;
  timer: TCountDown;
begin
  minLen := Self.MinimumTiles * RSTranslator.TileArea;

  Self.WhiteClusters := white.Cluster(1).SortBySize(True);
  Self.Doors := Self.FindDoors(red.Cluster(1.5), map);

  SetLength(connectA, Length(Self.Doors));
  SetLength(connectB, Length(Self.Doors));

  with white.Bounds() do
  begin
    SetLength(connectMap, Y2+1, X2+1);
    SetLength(Self.Matrix, Y2+1, X2+1);
  end;

  SetLength(doorMapA, Length(Self.WhiteClusters));
  SetLength(doorMapB, Length(Self.WhiteClusters));

  for i := 0 to High(Self.WhiteClusters) do
  begin
    if Length(Self.WhiteClusters[i]) < minLen then
      Continue;
    for pt in Self.WhiteClusters[i] do
      Self.Matrix[pt.Y, pt.X] := i;
  end;

  for i := 0 to High(Self.Doors) do
    Result.Nodes += Self.ProcessDoors(Self.Doors[i], i, n, doorMapA, doorMapB);

  timer.Start(4 * ONE_SECOND);
  SetLength(Result.Paths, Length(Result.Nodes));

  for i := 0 to High(Self.WhiteClusters) do
  begin
    if timer.IsFinished or (i = 0) or (i = High(Self.WhiteClusters)) then
    begin
      WriteLn GetDebugLn('Generating webgraph part ' + ToStr(i) + ' of ' + ToStr(High(Self.WhiteClusters)));
      timer.Restart();
    end;

    if not minRadius then
    begin
      Self.ProcessSmallCluster(Result, minRadius, doorMapA[i], doorMapB[i], i, minLen, connectA, connectB);
      if not minRadius then
        Continue;
    end;

    nodes := Self.SplitNodes(i);
    if nodes = [] then
      Continue;

    tree := TKDPointTree.Create(nodes);

    len := Length(Result.Nodes);
    SetLength(Result.Nodes, len + Length(nodes));
    SetLength(Result.Paths, Length(Result.Nodes));

    for j := 0 to High(tree.Data) do
      Self.PreProcessCluster(tree, connectMap, i, j);

    for j := 0 to High(tree.Data) do
      Self.ProcessCluster(Result, tree, connectMap, j, len);

    for j in doorMapA[i] + doorMapB[i] do
      Self.ConnectLastDoors(Result, i, j, tree);
  end;

  Self.Matrix := [];
end;

function TWebGraphGenerator.BuildGraph(name: String; map: TImage): TWebGraph;
var
  white, red, gray, merged, graySubset: TPointArray;
  grayClusters, mergedClusters: T2DPointArray;
  i, j: Integer;
  t: UInt64;
begin
  WriteLn GetDebugLn('Generating webgraph: ' + name + ' this can take a few seconds.');
  t := GetTimeRunning();

  white := map.FindColor($FFFFFF, 0);
  red := map.FindColor($0000FF, 0);
  gray := map.FindColor($333333, 0);

  Result := Self._BuildGraph(map, white, red);
  grayClusters := gray.Cluster(1);

  for i := 0 to High(Self.WhiteClusters) do
  begin
    if Length(Self.WhiteClusters[i]) <= 6 then
      Continue;

    graySubset := gray.ExtractBox(Self.WhiteClusters[i].Bounds().Expand(80));
    merged := Self.WhiteClusters[i] + graySubset;
    mergedClusters := merged.Cluster(1);

    for j := 0 to High(mergedClusters) do
      if mergedClusters[j].Contains(Self.WhiteClusters[i][0]) then
      begin
        Result.WalkableClusters += mergedClusters[j];
        Break;
      end;
  end;

  Result.WalkableSpace  := white + gray;
  Result.ObjectClusters := grayClusters;

  Self.WhiteClusters := [];
  WriteLn GetDebugLn('WebGraphGenerator', 'Generating webgraph took ' + ToStr(Round(((GetTimeRunning()-t)/1000), 2)) + ' seconds.', ELogLevel.SUCCESS);
end;

(*
## Webgraph Generation
If you do wish to understand the technical details a little bit more, the
following is a simplified explanation with images of more or less how it works.

First of all, you need to have a collision map. WaspLib's webgraph generator
assumes the walking space is white and that the doors are red, other than that,
it doesn't really matter what colors your collision map, for this explanation
I'm going to use a small piece of varrock with a bit of the wilderness:
```{figure} ../../images/graphgen0.png
```

We start off by extracting all the white:
```{figure} ../../images/graphgen1.png
```

Then, we cluster the white, grouping each white pixel that is within any other
white pixel horizontal or vertically in the same cluster. It's important to not
include diagonal pixels or your clusters will cross certain walls, at least in
WaspLib's collision maps. We also sort our clusters by size as we can have some
performance improvements by having the clusters sorted.

Doing this will look something like this:
```{figure} ../../images/graphgen2.png
```

We also need to find all the red to know where the doors are, in this image I've
expanded the color a little so it's visble but you should only get the door:
```{figure} ../../images/graphgen3.png
```

While doing this, you also want to get and store for later the point in front
and behind the door and map those points to each of your clusters.

The next step is to start processing our clusters. Because we sorted them by size
we start by skipping very small ones, usually clusters that are less than the
size of a tile.

Clusters that are less than `WebGraphGenerator.MinimumTiles` we add a single node
in the middle, it's a cluster too small to be worth extra processing.
Which would be the red nodes on the image below:
```{figure} ../../images/graphgen4.png
```

We also check our mapped doors to see if any of the points in front or behind
each door belongs to our cluster, if it does, we connect it to our node.

Then we start processing bigger clusters if you have
`WebGraphGenerator.Skeletonize` set to `True` which is the default, we will
sekeletonize the cluster which should look something like this:
```{figure} ../../images/graphgen5.png
```

And then we partition it with `WebGraphGenerator.Spacing`:
```{figure} ../../images/graphgen6.png
```

If you have `WebGraphGenerator.Skeletonize` set to `False`, we simply parition
the cluster as it is, again with `WebGraphGenerator.Spacing`.

It's hard to see much difference here but it's much denser than the above and
later on you will see the actual difference when paths are added:
```{figure} ../../images/graphgen7.png
```

Whichever case your settings followed, those will be your nodes for that cluster.

Then next step is to try and connect the nodes we just created by proximity.
We check `WebGraphGenerator.MaxConnections*2` closest nodes to each node and
connect up to `WebGraphGenerator.MaxConnections` if:
- We have a straight path between the 2 nodes
- If we can have a path using AStar

It should look something like this:
```{figure} ../../images/graphgen8.png
```

For AStar path finding we use the original skeleton/cluster and this is an
example of a connection where AStar was used:
```{figure} ../../images/graphgen9.png
```
As you can see that crossing over the wilderness river crossing black, it's
connected because AStar has found a path around it. That's also what's happening
on those nodes around trees with lines crossing the trees, there's a valid path
because AStar found a way around.

If you were to have `WebGraphGenerator.Skeletonize` set to `False`, this is what
the same thing would look like:
```{figure} ../../images/graphgen10.png
```

Lastly, we our mapped doors that has their front or behind point within our
cluster and connect that door to the closest
`WebGraphGenerator.MaxDoorConnections` amount of nodes:
```{figure} ../../images/graphgen11.png
```

And that's about it. The final graph should look like this if you
`WebGraphGenerator.Skeletonize` set to `True`, which again, is the default:
```{figure} ../../images/graphgen12.png
```

And this would be `WebGraphGenerator.Skeletonize` set to `False`:
```{figure} ../../images/graphgen13.png
```
*)

var
(*
## WebGraphGenerator variable
Global {ref}`TWebGraphGenerator` variable.
*)
  WebGraphGenerator: TWebGraphGenerator;
{$R+}
